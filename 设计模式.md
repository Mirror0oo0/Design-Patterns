## 七大软件设计原则

## 开闭原则

定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用细节扩展细节。

优点：提高软件系统的可复用性及可维护性。



## 依赖倒置原则

定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。

抽象不应该依赖细节；细节应该依赖抽象

针对借口编程，不要针对实现编程

优点：可以减少类间的耦合性、提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险。



## 单一职责

定义：不要存在多于一个导致类变更的原因

一个类、接口、方法只负责一项职责

优点：降低类的复杂度；提高类的可读性；提高系统的可维护性；降低变更引起的风险；



举例：

课程有两类：直播课、录播课。直播不能快进和快退，录播可以任意反复观看。

先创建一个Course类：

![image-20210818150411700](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210818150411.png)

代码调用：

![image-20210818150843273](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210818150843.png)

课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学员可以获得视频流，学习权限。这样在控制课程层面上至少有两个职责。我们需要把展示职责和管理职责分离出来，都实现同一个抽象依赖。

设计一个顶层接口，创建ICourse接口：

![image-20210818151242516](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210818151242.png)

把上面接口拆成两个，创建一个ICourseInfo和ICourseManager

![image-20210820104552452](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820104552.png)

![image-20210820104710891](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820104710.png)

![image-20210820104933462](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820104933.png)

modifyUserInfo()方法中都承担了多个职责，不符合单一职责原则。

![image-20210820105045949](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820105045.png)



## 接口隔离原则（Interface Segregation Principle）

定义：用多个专门的接口，而不是使用单一的总接口，客户端不应该依赖它不需要的接口

注意：

1、一个类对应一个类的依赖应该建立在最小的接口上

2、建立单一接口，不要建立庞大臃肿的解藕

3、尽量细化接口，接口中的方法尽量少。

![image-20210820111806980](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820111807.png)

![image-20210820113604970](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820113604.png)

## 迪米特法则（Law of Demeter）

定义：一个对象应该对其他对象保持最少的了解。又叫最少知道原则

尽量降低类与类之间的耦合

优点：降低类之间的耦合。

强调只和朋友交流，不和陌生人说话

朋友：出现在成员变量、方法的输入、输出参数中的类成为成员朋友类，而出现在方法体内部的类不属于朋友类。

![image-20210820115704182](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820115704.png)

![image-20210820115719754](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820115719.png)

根据迪米特原则，TeamLeader只想要结果，不需要跟Course产生直接交流。而Employee统计需要引用Course对象。TeamLeader和Course并不是朋友。

类图：

![image-20210820115908823](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820115908.png)

![image-20210820115928462](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820115928.png)

![image-20210820115940282](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210820115940.png)

## 里氏替换原则

定义太抽象



引申：子类可以扩展父类的功能，但不能改变父类原有的功能。

含义1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。

含义2、子类中可以增加自己特有的方法

含义3、当子类中可以增加自己特有的方法时，方法的前置条件（即方法的输入、入参数）要比父类方法更加宽松。

含义4、当子类的方法实现父类方法时（重写、重载或实现抽象方法）方法的后置条件（即方法的输入、返回值）要比父类更加严格或相等。



例子：

用正方形、矩形和四边形的关系说明里氏替换原则，正方形时一个特殊的长方形，那么就可以创建一个长方形父类Rectangle类：

![image-20210821000712892](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821000712.png)

创建正方形Square类继承长方形

![image-20210821000748389](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821000748.png)

![image-20210821000757829](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821000757.png)



在测试类中创建resize方法，长方形宽应该大于高，我们一直让高一直自增，直到高等于宽变成正方形。

![image-20210821002041948](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821002041.png)

![image-20210821002054745](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821002054.png)

正常



![image-20210821002519167](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821002519.png)

会出现死循坏。

里氏替换原则只存在父类与子类之间，约束继承泛滥。



创建长方形与正方形Quadrangle接口：

![image-20210821003008655](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003008.png)

![image-20210821003020604](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003020.png)

**![image-20210821003035895](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003035.png)**

![image-20210821003119536](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003119.png)



## 合成复用原则

是指尽量使用对象组合，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。

继承我们叫做白箱复用，相当于把素有实现细节暴露给子类。组合也称为黑箱复用，对类以外的对象时无法获取细节的。要根据具体的业务场景来做代码设计

![image-20210821003533116](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003533.png)

![image-20210821003543249](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003543.png)

这是一种典型的合成复用原则应用场景。但是目前DB Connection好不是抽象，不变蓝系统扩展。假如业务发生变化，数据库操作层药支持Oracle数据库。我们可以在DBConnection中增加对Oracle数据库支持的方法。但是违背来开闭原则。其实我们可以不必修改Dao代码。

先将DBCOnnection抽象化

![image-20210821003931224](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003931.png)

Mysql逻辑抽离

![image-20210821003950924](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821003950.png)

![image-20210821004000546](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821004000.png)

![image-20210821004051384](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821004051.png)



# 工厂模式

## 简单工厂模式

由一个工厂对象决定创建出哪一种产品类的实例。

![image-20210821113927089](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821113927.png)

如果增加课程需要去修改代码逻辑。不符合开闭原则，做一些改动，采用反射技术；同时对方法参数进行可控性，需要强制转型

```java
public ICourse create(Class<? extends ICourse> clazz){
  try{
    if(null != clazz){
      return clazz.newInstance();
    }
  }catch (Exception e){
    e.printStackTrace();
  }
  return null;
}
```

客户端代码

```java
public static void main(String[] args){
  CourseFactory factory = new CourseFactory();
  ICourse course = factory.create(JavaCourse.class);
  course.record();
}
```



在jdk中也存在着简单工厂模式

![image-20210821115210464](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821115210.png)

## 工厂方法模式

工厂方法模式是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

> 相比于简单工厂模式，原来类的实例化是在工厂类中实现的。现在是在子类中实现的。

工厂方法模式主要解决产品扩展问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑有区别的话，工厂的职责会变的越来越多，有点像万能工厂。

Java课程¥由Java工厂创建，Python课程由Python工厂创建。对工厂本身也做一个抽象。

先创建ICourseFactory接口：

![image-20210821151513189](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821151513.png)

![image-20210821151925965](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821151925.png)

测试代码：

![image-20210821152014453](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821152014.png)

> 工厂的工厂方法

工厂方法适用于以下场景：

1、创建对象需要大量重复代码

2、客户端（应用层）不依赖与产品类实例如果被创建、实现等细节。

3、一个类通过其子类来指定创建哪个对象。

工厂方法放缺点：

1、类的个数容易过多，增加复杂度

2、增加类系统的还凑喜爱难过性和理解难度 



> 简单工厂是产品的工厂，工厂方法是工厂的工厂。
>
> 



## 抽象工厂模式

定义：提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。

![image-20210821153921600](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821153921.png)

从上图中看，有正方形，圆形和棱形三种图形，相同颜色深浅的就代表同一个产品族，相同形状的代表同一个产品登记结构。

举例：颜色最深的正方形代表美的的洗衣机，颜色最深的图形代表美的的空调、颜色最深的菱形代表美的热水器，颜色最深的一排都属于美的的品牌，都是美的电器这个产品族。最右边的菱形，颜色最深的是我们指定代表美的热水器，第二排颜色稍微浅一点的菱形，代表海信的热水器。

![image-20210821155052722](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821155052.png)

上图中，左侧的小房子我们就认为具体的工厂，有美的的工厂，海信的工厂，格力工厂。每个品牌的工厂都生产洗衣机、热水器和空调。

相比上面的业务，现在课程不单单是一个课程信息，同时还要包含录播视频、课堂笔记甚至还要提供源码才能构成一个完整的课程。

在产品等级中增加两个产品Ivideo录播视频和INote课堂笔记。

IVideo接口：

```java
public interface IVideo{
  void record();
}
```

INote接口：

```java
public interface INote{
  void edit();
}
```

然后创建一个抽象工厂CourseFactory类：

```java
public abstract class CourseFactory{
  public void init(){
    System.out.println(“初始化基础数据”);
  }
  protected abstract INote createNote();
  protected abstract IVideo createVideo();
}
```

![image-20210821170126508](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821170126.png)

![image-20210821170138613](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821170138.png)

![image-20210821170930248](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821170930.png)

**![](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210821170930.png)**

​	完整描述类两个产品族Java课程和Python课程，也描述了两个产品等级视频笔记。如果要加入源码，那么我们的代码需要从抽象工厂，到具体工厂要全部调整。

缺点：

1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口

2、增加了系统的抽象性和理解难度。



适用于：客户端（应用层不依赖与产品类实例如何被创建、实现等细节）；强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。

提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现。



> 产品族：一系列相关的产品，整合到一起有关联性。
>
> 产品等级：同一个继承体系。



# 单例设计模式

定义：确保一个类在任何情况喜爱都绝对只有一个实例，并提供一个全局访问点。单例模式是创建模式。

单例模式在现实生活中应用也非常广泛，例如，公司CEO、部门经理。J2EE标准中的ServletContext、ServletContextConfig等、Spring框架应用中的ApplicationContext、数据库的连接池也都是单例形式。

## 饿汉式单例模式

饿汉式单例模式在类加载的时候就立即初始化，并且创建单例对象。它绝对线程安全，在线程还没出现以前就实例化了，不可能存在访问安全问题。

饿汉标准代码

![image-20210822101645030](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210822101645.png)

另一种写法，利用静态代码块的机制

![image-20210823202845292](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823202845.png)

优点：适用于单例对象少的情况。这样写可以保证线程安全、执行效率较高。

缺点：所有对象类加载的时候就实例化，如果系统中存在大批量的单例对象那系统初始化就会导致大量的内存浪费。

## 饱汉式单例模式

特点：单例对象要在被使用时才会初始化。

![image-20210823203954859](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823203954.png)

但是如果在多线程将出现线程安全问题



##  双重检查

![image-20210823205922897](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823205922.png)

优点：性能高了，线程安全了

缺点：可读性难度加大，不够优雅

## 静态内部类的写法

利用静态内部类的特点（只有在使用的时候才加载，不用的时候不加载）

```java
public class lazyStaticInnerClassSingleton{
  
 
  
  private lazyStaticInnerClassSingleton(){}
  
  private static lazyStaticInnerClassSingleton getInstance(){
    return LazyHolder.INSTANCE;
  }
  
  private static class LazyHolder{
    private static final lazyStaticInnerClassSingleton INSTANCE = new lazyStaticInnerClassSingleton();
  }
}
```

Classpath:lazyStaticInnerClassSingleton.class

Classpath:lazyStaticInnerClassSingleton$LazyHolder.class

在类路径是上面两个。



优点：写法优雅，利用了java本身的语法特点；避免了线程安全

缺点：能够被反射破坏。

类加载器在多线程的情况下会被同步加锁，第一次加载lazyStaticInnerClassSingleton的时候读取到了LazyHolder的类加载器，但不实例化，只有用的时候才实例化。



## 反射破坏单例

在上面的懒汉单例模式（静态内部类）变量，除了private没有加其他关键字。用反射调用其构造

![image-20210823224255710](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823224255.png)

我们做一次优化。在其构造方法中做一些限制，一旦出现多次重复创建，则知己二抛出异常

```java
public class lazyInnerClassSingleton{
  private LazyStaticInnerClassSingleton(){
    if(LazyHolder.INSTANCE !=null){
      throw new RunntimeExceprion("-----")
    }
  }
  //使用LazyInnerClassGeneral的时候，默认会先初始化内部类
  //如果没有使用，则内部类是不加载的
  private static final LazyInnerClassSingleton getInstance(){
    return lazyHolder.LAZY;
  }
  
  //默认不加载
  private static class LazyHolder{
    private static final LazyinnerClassSingleton LAZY = new lazyStaticInnerClassSingleton();
  }
}
```

优点：利用了Java本身语法特点，性能高，避免了内存的浪费，不能被反射破坏。

缺点：写法不够，不优雅



## 注册式单例模式

又被称为登记式单例；将每一个实例都缓存到统一容器中，使用唯一标识获取实例。

### 1、枚举式单例

```java
public enum EnumSingleton{
  INSTANCE;
  private Object data;
  public static Enum getInstance(){
    return INSTANCE;
  }
  
  public Object getData(){
    return data;
  }
  
  public void setData(Object data){
    this.data = data;
  }
  
}
```



```java
public class EnumSingletonTest{
  public static void main(String[] args){
    EnumSingleton instance = EnumSingleton.getInstance;
    instance.setData(new Object());
  }
}
```

************

**查看反射是否会破坏**

![image-20210823230324640](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823230324.png)

![image-20210823230341734](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823230341.png)

报错显示没有找到无参构造方法。

查看java.lang.Enum的源码，查看它的构造方法，只有一个protected类型的构造方法。

![image-20210823231036689](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231036.png)

如果使用有参的构造方法：

![image-20210823231111267](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231111.png)

![image-20210823231126063](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231126.png)

报错显示不能用反射创建枚举类型。进入Construct的newInstance()方法：

![截屏2021-08-23 下午11.12.39](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231413.png)

*****

**多线程的情况**

因为枚举类中的单例实例在类声明的时候就建好了（类声明的时候会加同步锁），创建好的枚举变量会存放在一个map中。

在Enum.java中有一个方法

![image-20210823231820623](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231820.png)

![image-20210823231913424](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231913.png)

![image-20210823231939713](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823231939.png)

这个enumConstanceDirectory相当于一个容器，又变成饿汉单例。

### 2、容器式单例

```java
public class ContainerSingleton{
  private ContainerSingleton(){}
  
  private static Map<String,Object> ioc = new ConcurrentHashMap<String,Object>;
  
  public static Object getInstance(String className){
    Object instance = null;
    if(!ios.containsKey(className)){
      try{
        instance = Class.forName(className).newInstance();
      ioc.put(className,instance);
      }catch(Exception e){
        e.printStackTrace();
      }
      return instance;
    }else{
      return ioc.get(className);
    }
  }
}
```

容器式单例模式适用于需要大量场阿金单例对象的场景，便于管理。但他是非线程安全的。

序列化会破坏单例？

## 序列化破坏单例

序列化：

把内存中对象的状态转换为字节码形式

把字节码通过IO输出流，写到磁盘上去

永久保存下来，持久化。



反序列化：

将持久化的字节码内容，通过Io输入流读到内存中

转化为一个Java对象。



用最普通的饿汉式单例做测试

![image-20210823234054741](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823234054.png)

![image-20210823234106805](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823234106.png)

![image-20210823234130323](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823234130.png)

运行结果显示，对象不一致，实例化了两次；

==<font color="red">解决方法：</font>==

==增加一个readResolve（）方法==

```java
public SeriableSingleton implements Serializable{
  private final static SeriableSingleton INSTANCE = new SeriableSingleton();
  private SeriableSingleton(){}
  
  public static SeriableSingleton getInstance(){
    return INSTANCE;
  }
  private Object readResolve(){
    return INSTANCE;
  }
  
}
```

原因：

查看ObjectInputStream类的readObject()方法

![image-20210823235847027](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210823235847.png)

![image-20210824000213958](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210824000214.png)

checkResolve就是去检查有没有写reolve方法

![image-20210824000604680](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210824000604.png)

![image-20210824000634873](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210824000634.png)

==isInstantiable()方法就是简单的判断一下能否被事例化。==

能实例化就先创建一个



然后

![image-20220425233307662](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20220425233307.png)

![image-20220425233425614](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20220425233425.png)

![image-20220425234235685](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20220425234235.png)

>在上述的readOrdinaryObject()方法中，通过desc.hasReadResolveMethod()检查类中是否存在名为readResolve()的方法，如果有，就执行desc.invokeReadResolve(obj)调用readResolve()方法。readResolve()会用自定义的反序列化逻辑覆盖默认实现，因此强制它返回instance本身，就可以防止产生新的实例。



### 线程单例实现 ThreadLocal

ThreadLocal不能保证其创建的对象是全局唯一的，但是能保证在单个线程中是唯一的，天生是线程安全的。

```java
public class ThreadLocalSingleton{
  private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance = new ThreadLocal<ThreadLocalSingleton>(){
    @Override
    protected ThreadLocalSingleton initialValue(){
      return new ThreadLocalSingleton();
    }
  };
  private ThreadLocalSingleton(){}
  public static ThreadLocalSingleton getInstance(){
    return threadLocalInstance.get();
  }
}
```

```java
public class ExectorThread implements Runnable{
  public void run(){
    ThreadLocalSingleton instance = ThreadLocalSingleton.getinstance();
    System.out,println(Thread.currentThread().getName() + ":" + instance);
  }
}
```

![image-20210824091455429](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210824091455.png)

运行结果

![image-20210824091525294](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210824091525.png)



在主线程中无论调用多少次，获取到的实例都是同一个，在不同的两个子线程不一样的实例。

ThreadLocal将所有的对象全部放在ThreadLocalMap中，为每个线程都提供一个对象，实际上是以空间来实现线程隔离的。



## 总结

**优点**

- 内存中只有一个实例，减少了内存的开销
- 可以避免对资源的多重占用
- 设置全局访问点，严格控制访问

**缺点**

- 没有借口，扩展困难
- 如果要扩展单例对象，只有修改代码，没有其他途径



==1、私有化构造器==

==2、保证线程安全==

==3、延迟加载==

==4、防止序列化和反序列化破坏单例==

==5、防御反射攻击单例==





# 原型模型

原型模式（Prototype Pattern）：是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

调用者不需要知道任何创建细节，不调用构造函数。

属于创建型模式。

```java
public interface IPrototype<T> {
    T clone();
}
```

```java
public class ConcretePrototype implements IPrototype {

    private int age;
    private String name;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public ConcretePrototype clone() {
        ConcretePrototype concretePrototype = new ConcretePrototype();
        concretePrototype.setAge(this.age);
        concretePrototype.setName(this.name);
        return concretePrototype;
    }

    @Override
    public String toString() {
        return "ConcretePrototype{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
```

```java
public class Client {


    public static void main(String[] args) {
        //创建原型对象
        ConcretePrototype prototype = new ConcretePrototype();
        prototype.setAge(18);
        prototype.setName("Tom");
        System.out.println(prototype);


        //拷贝原型对象
        ConcretePrototype cloneType = prototype.clone();
        System.out.println(cloneType);

    }


}
```

![image-20210828205036611](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210828205036.png)

## 原型模式适用场景

1、类初始化消耗资源较多

2、new产生一个对象需要非常繁琐的过程（数据准备、访问权限）

3、构造函数比较复杂

4、循坏体中生产大量对象时。

## 原型模式通用写法

### 浅克隆

JDK已经帮我们实现了一个现成的API，我们只需要实现Cloneable接口即可。并增加一个爱好hobbies属性。api里面的clone就是利用java低层的字节流来完成复制的

```java
public class ConcretePrototype implements Cloneable {

    private int age;
    private String name;
    private List<String> hobbies;

    @Override
    public ConcretePrototype clone() {
        try {
            return (ConcretePrototype)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public String toString() {
        return "ConcretePrototype{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}
```

![image-20210828224224570](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210828224224.png)

给复制后的克隆对象新增一项爱好，原型也发生了变化，不合符我们的预期。hobbies共用了一个内存地址，意味着复制的不是值，而是引用地址。



### 使用序列化实现深度克隆

需要类实现序列化接口

```java
@Data
public class ConcretePrototype implements Cloneable,Serializable {

    private int age;
    private String name;
    private List<String> hobbies;

    @Override
    public ConcretePrototype clone() {
        try {
            return (ConcretePrototype)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }

    public ConcretePrototype deepCloneHobbies(){
        try {
            ConcretePrototype result = (ConcretePrototype)super.clone();
            result.hobbies = (List)((ArrayList)result.hobbies).clone();
            return result;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }

    public ConcretePrototype deepClone(){
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);

            return (ConcretePrototype)ois.readObject();
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }


    }

    @Override
    public String toString() {
        return "ConcretePrototype{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}
```

另外一种方法是 先转换为json 再转换为对象。



## 克隆破坏单例模式

如果我们克隆的目标对象是单例对象，那意味着，深克隆就会破坏单例。实际上防止克隆破坏单例解决思路非常简单，禁止深克隆便可。要么我们的单例类不实现Cloneable接口；要么我们重写clone()方法；

```java
@Override
protected OBject clone() throws CloneNotSupportedException{
  return INSTANCE;
}
```



## 克隆在jDK源码中的运用

ArrayLIst实现

![image-20210828231116891](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210828231116.png)

![image-20210828231141395](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210828231141.png)

重新给数组new类一下，是深克隆；

这种方法是硬编码，如果在对象中声明了各种集合类型，那每种情况都需要单独处理。因此，深克隆的写法，一般直接用序列化操作。

## 原型模式的优点

优点：

1、性能优良，Java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能行提升了许多。

2、可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

缺点：

1、需要为每一个类配置一个克隆方法。

2、克隆方法位于类的内部，当已有类进行改造的时候，需要修改代码，违反了开闭原则。

3、子啊实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来回比较麻烦。因此深拷贝、潜拷贝需要运用得当。





# 建造者模式

定义：是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

特征：用户只需要指定需要建造的类型就可以获得对象，建造过程及细节不需要了解。

属于创建型模式 



## 建造者模式的基本写法

```java
@Data
public class Course {

    private String name;
    private String ppt;
    private String video;
    private String note;

    private String homework;

    @Override
    public String toString() {
        return "CourseBuilder{" +
                "name='" + name + '\'' +
                ", ppt='" + ppt + '\'' +
                ", video='" + video + '\'' +
                ", note='" + note + '\'' +
                ", homework='" + homework + '\'' +
                '}';
    }
}
```

```java
public class CourseBuilder{

    private Course course = new Course();

    public void addName(String name) {
        course.setName(name);
    }
    
    public void addPPT(String ppt) {
        course.setPpt(ppt);
    }
    
    public void addVideo(String video) {
        course.setVideo(video);
    }
    
    public void addNote(String note) {
        course.setNote(note);
    }
    
    public void addHomework(String homework) {
        course.setHomework(homework);
    }
    
    public Course build() {
        return course;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        CourseBuilder builder = new CourseBuilder();

        builder.addName("设计模式");
        builder.addPPT("【PPT课件】");
        builder.addVideo("【回放视频】");
        builder.addNote("【课堂笔记】");
        builder.addHomework("【课后作业】");

        System.out.println(builder.build());

    }
}
```



## 建造者模式的链式写法

![image-20210829103538999](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829103539.png)

上面的写法过于麻烦。

```java
public class CourseBuilder {
    private Course course = new Course();

    public CourseBuilder addName(String name) {
        course.setName(name);
        return this;
    }

    public CourseBuilder addPPT(String ppt) {
        course.setPpt(ppt);
        return this;
    }

    public CourseBuilder addVideo(String video) {
        course.setVideo(video);
        return this;
    }

    public CourseBuilder addNote(String note) {
        course.setNote(note);
        return this;
    }

    public CourseBuilder addHomework(String homework) {
        course.setHomework(homework);
        return this;
    }

    public Course build() {
        return this.course;
    }

    @Data
    public class Course {

        private String name;
        private String ppt;
        private String video;
        private String note;

        private String homework;

        @Override
        public String toString() {
            return "CourseBuilder{" +
                    "name='" + name + '\'' +
                    ", ppt='" + ppt + '\'' +
                    ", video='" + video + '\'' +
                    ", note='" + note + '\'' +
                    ", homework='" + homework + '\'' +
                    '}';
        }
    }

}
```

只需要在add函数里返回this就可以实现

```java
public class Test {
    public static void main(String[] args) {
        CourseBuilder builder = new CourseBuilder()
                    .addName("设计模式")
                    .addPPT("【PPT课件】")
                    .addVideo("【回放视频】")
                    .addNote("【课堂笔记】")
                    .addHomework("【课后作业】");

        System.out.println(builder.build());



        StringBuilder sb = new StringBuilder();
        sb.append("");


        CacheBuilder cacheBuilder = new CacheBuilder("");
        cacheBuilder.blocking(false);
//        cacheBuilder.

        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
//        sqlSessionFactoryBuilder.


        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition();
//        beanDefinitionBuilder.



    }
}
```

![image-20210829103714317](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829103714.png)

## 建造者模式在源码中的体现

StringBuilder 的append()方法

![image-20210829105818613](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829105818.png)



*******

**参考开源框架JPA的SQL构造模式**

```java
/**
 * QueryRule,主要功能用于构造查询条件
 * 
 * @author Tom
 */
public final class QueryRule implements Serializable
{
   private static final long serialVersionUID = 1L;
   public static final int ASC_ORDER = 101;
   public static final int DESC_ORDER = 102;
   public static final int LIKE = 1;
   public static final int IN = 2;
   public static final int NOTIN = 3;
   public static final int BETWEEN = 4;
   public static final int EQ = 5;
   public static final int NOTEQ = 6;
   public static final int GT = 7;
   public static final int GE = 8;
   public static final int LT = 9;
   public static final int LE = 10;
   public static final int ISNULL = 11;
   public static final int ISNOTNULL = 12;
   public static final int ISEMPTY = 13;
   public static final int ISNOTEMPTY = 14;
   public static final int AND = 201;
   public static final int OR = 202;
   private List<Rule> ruleList = new ArrayList<Rule>();
   private List<QueryRule> queryRuleList = new ArrayList<QueryRule>();
   private String propertyName;

   private QueryRule() {}

   private QueryRule(String propertyName) {
      this.propertyName = propertyName;
   }

   public static QueryRule getInstance() {
      return new QueryRule();
   }
   
   /**
    * 添加升序规则
    * @param propertyName
    * @return
    */
   public QueryRule addAscOrder(String propertyName) {
      this.ruleList.add(new Rule(ASC_ORDER, propertyName));
      return this;
   }

   /**
    * 添加降序规则
    * @param propertyName
    * @return
    */
   public QueryRule addDescOrder(String propertyName) {
      this.ruleList.add(new Rule(DESC_ORDER, propertyName));
      return this;
   }

   public QueryRule andIsNull(String propertyName) {
      this.ruleList.add(new Rule(ISNULL, propertyName).setAndOr(AND));
      return this;
   }

   public QueryRule andIsNotNull(String propertyName) {
      this.ruleList.add(new Rule(ISNOTNULL, propertyName).setAndOr(AND));
      return this;
   }

   public QueryRule andIsEmpty(String propertyName) {
      this.ruleList.add(new Rule(ISEMPTY, propertyName).setAndOr(AND));
      return this;
   }

   public QueryRule andIsNotEmpty(String propertyName) {
      this.ruleList.add(new Rule(ISNOTEMPTY, propertyName).setAndOr(AND));
      return this;
   }

   public QueryRule andLike(String propertyName, Object value) {
      this.ruleList.add(new Rule(LIKE, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }

   public QueryRule andEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(EQ, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }

   public QueryRule andBetween(String propertyName, Object... values) {
      this.ruleList.add(new Rule(BETWEEN, propertyName, values).setAndOr(AND));
      return this;
   }

   public QueryRule andIn(String propertyName, List<Object> values) {
      this.ruleList.add(new Rule(IN, propertyName, new Object[] { values }).setAndOr(AND));
      return this;
   }

   public QueryRule andIn(String propertyName, Object... values) {
      this.ruleList.add(new Rule(IN, propertyName, values).setAndOr(AND));
      return this;
   }
   
   public QueryRule andNotIn(String propertyName, List<Object> values) {
      this.ruleList.add(new Rule(NOTIN, propertyName, new Object[] { values }).setAndOr(AND));
      return this;
   }

   public QueryRule orNotIn(String propertyName, Object... values) {
      this.ruleList.add(new Rule(NOTIN, propertyName, values).setAndOr(OR));
      return this;
   }
   

   public QueryRule andNotEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(NOTEQ, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }

   public QueryRule andGreaterThan(String propertyName, Object value) {
      this.ruleList.add(new Rule(GT, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }

   public QueryRule andGreaterEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(GE, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }

   public QueryRule andLessThan(String propertyName, Object value) {
      this.ruleList.add(new Rule(LT, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }

   public QueryRule andLessEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(LE, propertyName, new Object[] { value }).setAndOr(AND));
      return this;
   }
   
   
   public QueryRule orIsNull(String propertyName) {
      this.ruleList.add(new Rule(ISNULL, propertyName).setAndOr(OR));
      return this;
   }

   public QueryRule orIsNotNull(String propertyName) {
      this.ruleList.add(new Rule(ISNOTNULL, propertyName).setAndOr(OR));
      return this;
   }

   public QueryRule orIsEmpty(String propertyName) {
      this.ruleList.add(new Rule(ISEMPTY, propertyName).setAndOr(OR));
      return this;
   }

   public QueryRule orIsNotEmpty(String propertyName) {
      this.ruleList.add(new Rule(ISNOTEMPTY, propertyName).setAndOr(OR));
      return this;
   }

   public QueryRule orLike(String propertyName, Object value) {
      this.ruleList.add(new Rule(LIKE, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }

   public QueryRule orEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(EQ, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }

   public QueryRule orBetween(String propertyName, Object... values) {
      this.ruleList.add(new Rule(BETWEEN, propertyName, values).setAndOr(OR));
      return this;
   }

   public QueryRule orIn(String propertyName, List<Object> values) {
      this.ruleList.add(new Rule(IN, propertyName, new Object[] { values }).setAndOr(OR));
      return this;
   }

   public QueryRule orIn(String propertyName, Object... values) {
      this.ruleList.add(new Rule(IN, propertyName, values).setAndOr(OR));
      return this;
   }

   public QueryRule orNotEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(NOTEQ, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }

   public QueryRule orGreaterThan(String propertyName, Object value) {
      this.ruleList.add(new Rule(GT, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }

   public QueryRule orGreaterEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(GE, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }

   public QueryRule orLessThan(String propertyName, Object value) {
      this.ruleList.add(new Rule(LT, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }

   public QueryRule orLessEqual(String propertyName, Object value) {
      this.ruleList.add(new Rule(LE, propertyName, new Object[] { value }).setAndOr(OR));
      return this;
   }
   

   public List<Rule> getRuleList() {
      return this.ruleList;
   }

   public List<QueryRule> getQueryRuleList() {
      return this.queryRuleList;
   }

   public String getPropertyName() {
      return this.propertyName;
   }

   protected class Rule implements Serializable {
      private static final long serialVersionUID = 1L;
      private int type;  //规则的类型
      private String property_name;
      private Object[] values;
      private int andOr = AND;

      public Rule(int paramInt, String paramString) {
         this.property_name = paramString;
         this.type = paramInt;
      }

      public Rule(int paramInt, String paramString,
            Object[] paramArrayOfObject) {
         this.property_name = paramString;
         this.values = paramArrayOfObject;
         this.type = paramInt;
      }
      
      public Rule setAndOr(int andOr){
         this.andOr = andOr;
         return this;
      }
      
      public int getAndOr(){
         return this.andOr;
      }

      public Object[] getValues() {
         return this.values;
      }

      public int getType() {
         return this.type;
      }

      public String getPropertyName() {
         return this.property_name;
      }
   }
}
```

```java
/**
 * 根据QueryRule自动构建sql语句
 * @author Tom
 *
 */
public class QueryRuleSqlBuilder {
   private int CURR_INDEX = 0; //记录参数所在的位置
   private List<String> properties; //保存列名列表
   private List<Object> values; //保存参数值列表
   private List<Order> orders; //保存排序规则列表
   
   private String whereSql = ""; 
   private String orderSql = "";
   private Object [] valueArr = new Object[]{};
   private Map<Object,Object> valueMap = new HashMap<Object,Object>();
   
   /**
    * 或得查询条件
    * @return
    */
   private String getWhereSql(){
      return this.whereSql;
   }
   
   /**
    * 获得排序条件
    * @return
    */
   private String getOrderSql(){
      return this.orderSql;
   }
   
   /**
    * 获得参数值列表
    * @return
    */
   public Object [] getValues(){
      return this.valueArr;
   }
   
   /**
    * 获取参数列表
    * @return
    */
   private Map<Object,Object> getValueMap(){
      return this.valueMap;
   }
   
   /**
    * 创建SQL构造器
    * @param queryRule
    */
   public QueryRuleSqlBuilder(QueryRule queryRule) {
      CURR_INDEX = 0;
      properties = new ArrayList<String>();
      values = new ArrayList<Object>();
      orders = new ArrayList<Order>();
      for (QueryRule.Rule rule : queryRule.getRuleList()) {
         switch (rule.getType()) {
         case QueryRule.BETWEEN:
            processBetween(rule);
            break;
         case QueryRule.EQ:
            processEqual(rule);
            break;
         case QueryRule.LIKE:
            processLike(rule);
            break;
         case QueryRule.NOTEQ:
            processNotEqual(rule);
            break;
         case QueryRule.GT:
            processGreaterThen(rule);
            break;
         case QueryRule.GE:
            processGreaterEqual(rule);
            break;
         case QueryRule.LT:
            processLessThen(rule);
            break;
         case QueryRule.LE:
            processLessEqual(rule);
            break;
         case QueryRule.IN:
            processIN(rule);
            break;
         case QueryRule.NOTIN:
            processNotIN(rule);
            break;
         case QueryRule.ISNULL:
            processIsNull(rule);
            break;
         case QueryRule.ISNOTNULL:
            processIsNotNull(rule);
            break;
         case QueryRule.ISEMPTY:
            processIsEmpty(rule);
            break;
         case QueryRule.ISNOTEMPTY:
            processIsNotEmpty(rule);
            break;
         case QueryRule.ASC_ORDER:
            processOrder(rule);
            break;
         case QueryRule.DESC_ORDER:
            processOrder(rule);
            break;
         default:
            throw new IllegalArgumentException("type " + rule.getType() + " not supported.");
         }
      }
      //拼装where语句
      appendWhereSql();
      //拼装排序语句
      appendOrderSql();
      //拼装参数值
      appendValues();
   }
   
   /**
    * 去掉order
    * 
    * @param sql
    * @return
    */
   private String removeOrders(String sql) {
      Pattern p = Pattern.compile("order\\s*by[\\w|\\W|\\s|\\S]*", Pattern.CASE_INSENSITIVE);
      Matcher m = p.matcher(sql);
      StringBuffer sb = new StringBuffer();
      while (m.find()) {
         m.appendReplacement(sb, "");
      }
      m.appendTail(sb);
      return sb.toString();
   }
   
   /**
    * 去掉select
    * 
    * @param sql
    * @return
    */
   private String removeSelect(String sql) {
      if(sql.toLowerCase().matches("from\\s+")){
         int beginPos = sql.toLowerCase().indexOf("from");
         return sql.substring(beginPos);
      }else{
         return sql;
      }
   }
   
   /**
    * 处理like
    * @param rule
    */
   private  void processLike(QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      Object obj = rule.getValues()[0];

      if (obj != null) {
         String value = obj.toString();
         if (!StringUtils.isEmpty(value)) {
            value = value.replace('*', '%');
            obj = value;
         }
      }
      add(rule.getAndOr(),rule.getPropertyName(),"like","%"+rule.getValues()[0]+"%");
   }

   /**
    * 处理between
    * @param rule
    */
   private  void processBetween(QueryRule.Rule rule) {
      if ((ArrayUtils.isEmpty(rule.getValues()))
            || (rule.getValues().length < 2)) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),"","between",rule.getValues()[0],"and");
      add(0,"","","",rule.getValues()[1],"");
   }
   
   /**
    * 处理 =
    * @param rule
    */
   private  void processEqual(QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),"=",rule.getValues()[0]);
   }

   /**
    * 处理 <>
    * @param rule
    */
   private  void processNotEqual(QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),"<>",rule.getValues()[0]);
   }

   /**
    * 处理 >
    * @param rule
    */
   private  void processGreaterThen(
         QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),">",rule.getValues()[0]);
   }

   /**
    * 处理>=
    * @param rule
    */
   private  void processGreaterEqual(
         QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),">=",rule.getValues()[0]);
   }

   /**
    * 处理<
    * @param rule
    */
   private  void processLessThen(QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),"<",rule.getValues()[0]);
   }

   /**
    * 处理<=
    * @param rule
    */
   private  void processLessEqual(
         QueryRule.Rule rule) {
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      add(rule.getAndOr(),rule.getPropertyName(),"<=",rule.getValues()[0]);
   }

   /**
    * 处理  is null
    * @param rule
    */
   private  void processIsNull(QueryRule.Rule rule) {
      add(rule.getAndOr(),rule.getPropertyName(),"is null",null);
   }

   /**
    * 处理 is not null
    * @param rule
    */
   private  void processIsNotNull(QueryRule.Rule rule) {
      add(rule.getAndOr(),rule.getPropertyName(),"is not null",null);
   }

   /**
    * 处理  <>''
    * @param rule
    */
   private  void processIsNotEmpty(QueryRule.Rule rule) {
      add(rule.getAndOr(),rule.getPropertyName(),"<>","''");
   }

   /**
    * 处理 =''
    * @param rule
    */
   private  void processIsEmpty(QueryRule.Rule rule) {
      add(rule.getAndOr(),rule.getPropertyName(),"=","''");
   }

   
   /**
    * 处理in和not in
    * @param rule
    * @param name
    */
   private void inAndNotIn(QueryRule.Rule rule,String name){
      if (ArrayUtils.isEmpty(rule.getValues())) {
         return;
      }
      if ((rule.getValues().length == 1) && (rule.getValues()[0] != null)
            && (rule.getValues()[0] instanceof List)) {
         List<Object> list = (List) rule.getValues()[0];
         
         if ((list != null) && (list.size() > 0)){
            for (int i = 0; i < list.size(); i++) {
               if(i == 0 && i == list.size() - 1){
                  add(rule.getAndOr(),rule.getPropertyName(),"",name + " (",list.get(i),")");
               }else if(i == 0 && i < list.size() - 1){
                  add(rule.getAndOr(),rule.getPropertyName(),"",name + " (",list.get(i),"");
               }
               if(i > 0 && i < list.size() - 1){
                  add(0,"",",","",list.get(i),"");
               }
               if(i == list.size() - 1 && i != 0){
                  add(0,"",",","",list.get(i),")");
               }
            }
         }
      } else {
         Object[] list =  rule.getValues();
         for (int i = 0; i < list.length; i++) {
            if(i == 0 && i == list.length - 1){
               add(rule.getAndOr(),rule.getPropertyName(),"",name + " (",list[i],")");
            }else if(i == 0 && i < list.length - 1){
               add(rule.getAndOr(),rule.getPropertyName(),"",name + " (",list[i],"");
            }
            if(i > 0 && i < list.length - 1){
               add(0,"",",","",list[i],"");
            }
            if(i == list.length - 1 && i != 0){
               add(0,"",",","",list[i],")");
            }
         }
      }
   }
   
   /**
    * 处理 not in
    * @param rule
    */
   private void processNotIN(QueryRule.Rule rule){
      inAndNotIn(rule,"not in");
   }
   
   /**
    * 处理 in
    * @param rule
    */
   private  void processIN(QueryRule.Rule rule) {
      inAndNotIn(rule,"in");
   }
   
   /**
    * 处理 order by
    * @param rule 查询规则
    */
   private void processOrder(Rule rule) {
      switch (rule.getType()) {
      case QueryRule.ASC_ORDER:
         // propertyName非空
         if (!StringUtils.isEmpty(rule.getPropertyName())) {
            orders.add(Order.asc(rule.getPropertyName()));
         }
         break;
      case QueryRule.DESC_ORDER:
         // propertyName非空
         if (!StringUtils.isEmpty(rule.getPropertyName())) {
            orders.add(Order.desc(rule.getPropertyName()));
         }
         break;
      default:
         break;
      }
   }
   
   
   /**
    * 加入到sql查询规则队列
    * @param andOr and 或者 or
    * @param key 列名
    * @param split 列名与值之间的间隔
    * @param value 值
    */
   private  void add(int andOr,String key,String split ,Object value){
      add(andOr,key,split,"",value,"");
   }
   
   /**
    * 加入到sql查询规则队列
    * @param andOr and 或则 or
    * @param key 列名
    * @param split 列名与值之间的间隔
    * @param prefix 值前缀
    * @param value 值
    * @param suffix 值后缀
    */
   private  void add(int andOr,String key,String split ,String prefix,Object value,String  suffix){
      String andOrStr = (0 == andOr ? "" :(QueryRule.AND == andOr ? " and " : " or "));  
      properties.add(CURR_INDEX, andOrStr + key + " " + split + prefix + (null != value ? " ? " : " ") + suffix);
      if(null != value){
         values.add(CURR_INDEX,value);
         CURR_INDEX ++;
      }
   }
   
   
   /**
    * 拼装 where 语句
    */
   private void appendWhereSql(){
      StringBuffer whereSql = new StringBuffer();
      for (String p : properties) {
         whereSql.append(p);
      }
      this.whereSql = removeSelect(removeOrders(whereSql.toString()));
   }
   
   /**
    * 拼装排序语句
    */
   private void appendOrderSql(){
      StringBuffer orderSql = new StringBuffer();
      for (int i = 0 ; i < orders.size(); i ++) {
         if(i > 0 && i < orders.size()){
            orderSql.append(",");
         }
         orderSql.append(orders.get(i).toString());
      }
      this.orderSql = removeSelect(removeOrders(orderSql.toString()));
   }
   
   /**
    * 拼装参数值
    */
   private void appendValues(){
      Object [] val = new Object[values.size()];
      for (int i = 0; i < values.size(); i ++) {
         val[i] = values.get(i);
         valueMap.put(i, values.get(i));
      }
      this.valueArr = val;
   }

   public String builder(String tableName){
      String ws = removeFirstAnd(this.getWhereSql());
      String whereSql = ("".equals(ws) ? ws : (" where " + ws));
      String sql = "select * from " + tableName + whereSql;
      Object [] values = this.getValues();
      String orderSql = this.getOrderSql();
      orderSql = (StringUtils.isEmpty(orderSql) ? " " : (" order by " + orderSql));
      sql += orderSql;
      return sql;
   }


   private String removeFirstAnd(String sql){
      if(StringUtils.isEmpty(sql)){return sql;}
      return sql.trim().toLowerCase().replaceAll("^\\s*and", "") + " ";
   }

}
```

```java
public class Test {
    public static void main(String[] args) {
        QueryRule queryRule = QueryRule.getInstance();
        queryRule.addAscOrder("age").
                andEqual("addr","Changsha").
                andLike("name","Tom");
        QueryRuleSqlBuilder builder = new QueryRuleSqlBuilder(queryRule);

        System.out.println(builder.builder("t_member"));

        System.out.println("Params: " + Arrays.toString(builder.getValues()));


    }
}
```



______________________

在Mybatis中也有体现，CacheBuilder

![image-20210829112450603](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829112450.png)



SqlSessionFactoryBuilder

![image-20210829112526352](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829112526.png)

________

Spring中的BeanDefinitionBuilder通过调用getBeanDefinition()方法

![image-20210829112638177](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829112638.png)



> 建造者模式能够实现定制化构造，中间的构造细节忽略，最后返回的结果得到控制。



## 建造者模式的优缺点

建造者模式的优点：

1、封装性好，创建和使用分离

2、扩展性好，建造类之间独立、一定程度上解耦。

建造者模式的缺点：

1、产生多余的Builder对象。

2、产品内部发生变化，建造者都要修改，成本较大。



## 建造者和工厂对比

1、建造者模式更加注重方法的调用顺序，工厂模式注重于创建对象。

2、创建对象的力度不同，建造者模式创阿金复杂对象，由各种复杂的部件组成，工厂模式创建出来的都是一样的。

3、关注点：工厂模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成。

4、建造者模式根据建造过程中的顺序不一样，最终的对象不剪组成也不一样。





# 代理模式（proxy patten）

定义：是指为其他对象提供一种代理，以控制对这个对象的访问。

代理对象在客服端和目标对象之间起到中介作用。

数据结构型设计模式

![image-20210829134013664](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829134013.png)



## 静态代理

```Java
/*
	抽象主题角色（Subject）:抽象主题类的主要职责是声明真实主题与代理的共同接口方法，该类可以是接口也可以是抽象类；
*/
public interface ISubject {
    void request();
}
```

```java
/*
	Proxy：代理类，其内部持有RealSubject的引用，因此具备完全的对RealSubject的代理权。客户端调用代理对象的方法，同时也调用被代理对象的方法，但是会在代理对象前后增加一个处理代码。
*/
public class Proxy implements ISubject {

    private ISubject subject;

    public Proxy(ISubject subject){
        this.subject = subject;
    }


    public void request() {
        before();
        subject.request();
        after();
    }

    public void before(){
        System.out.println("called before request().");
    }

    public void after(){
        System.out.println("called after request().");
    }
}
```

```java
/*
	真实主题角色（RealSubject）：该类也被称为被代理类，该类定义了代理所表示的真实对象，是负责执行系统真正的逻辑业务对象。
*/
public class RealSubject implements ISubject {

    public void request() {
        System.out.println("real service is called.");
    }

}
```

```java
public class Client {

    public static void main(String[] args) {

        Proxy proxy = new Proxy(new RealSubject());
        proxy.request();

    }

}
```

> 一般代理会被理解为代码增强，实际上就是在源代码前后增加一些代码逻辑，而使调用者无感知。代理模式属于结构性模型，分为静态和动态。



## 静态转动态代理

```java
public interface IPerson {

    void findLove();

}
```

```java
public class ZhangSan implements IPerson {

    public void findLove() {
        System.out.println("儿子要求：肤白貌美大长腿");
    }

}
```

```java
public class ZhaoLiu implements IPerson {

    public void findLove() {

    }

}
```

```java
public class ZhangLaosan implements IPerson {

    private ZhangSan zhangsan;

    public ZhangLaosan(ZhangSan zhangsan) {
        this.zhangsan = zhangsan;
    }

    public void findLove() {
        System.out.println("张老三开始物色");
        zhangsan.findLove();
        System.out.println("开始交往");
    }

}
```

这里父亲只会给自己儿子找对象。但是婚介所需要只要是person就给找对象。

现在用的多的是JDK自带的代理和Cglib提供的类库。

> 这些底层都是通过字节码重组实现的新的类

### 使用JDK自带的API

```java
public class Zhangsan implements IPerson {

    public void findLove() {
        System.out.println("张三要求：肤白貌美大长腿");
    }

    public void buyInsure() {
        System.out.println("30万");
    }

}
```

```java
public class ZhaoLiu implements IPerson {

    public void findLove() {
        System.out.println("赵六要求：有车有房学历高");
    }

    public void buyInsure() {

    }

}
```

```java
public class JdkMeipo implements InvocationHandler {
    private IPerson target;
    public IPerson getInstance(IPerson target){
        this.target = target;
        Class<?> clazz =  target.getClass();
        return (IPerson) Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this);
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(this.target,args);
        after();
        return result;
    }

    private void after() {
        System.out.println("双方同意，开始交往");
    }

    private void before() {
        System.out.println("我是媒婆，已经收集到你的需求，开始物色");
    }
}
```

代理都用jdk自带的`Proxy.newProxyInstance()`的方法来实现。

![image-20210829175021699](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829175021.png)

实现InvocationHandler接口需要重写![image-20210829175232724](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829175232.png)

方法。这个方法可以由newProxyInstance（）方法生成的对象动态的去调用。Object proxy能够拿到调用这个方法的对象，Method method是调用的这个方法，Object[] args是拿到这个方法的参数。

![image-20210829180007489](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829180007.png)

```java
public class Test {
    public static void main(String[] args) {
        JdkMeipo jdkMeipo = new JdkMeipo();
        IPerson zhangsan = jdkMeipo.getInstance(new Zhangsan());
        zhangsan.findLove();


        IPerson zhaoliu = jdkMeipo.getInstance(new ZhaoLiu());
        zhaoliu.findLove();

    }
}
```

如果对于一写公共方法可以抽离出来写在IPerson接口中。



### 使用Cglib实现动态代理

要引入

```properties
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib-nodep</artifactId>
    <version>2.2</version>
</dependency>
```

```java
public class CGlibMeipo implements MethodInterceptor {


    public Object getInstance(Class<?> clazz) throws Exception{
        //相当于Proxy，代理的工具类
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        return enhancer.create();
    }

    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object obj = methodProxy.invokeSuper(o,objects);
        after();
        return obj;
    }

    private void before(){
        System.out.println("我是媒婆，我要给你找对象，现在已经确认你的需求");
        System.out.println("开始物色");
    }

    private void after(){
        System.out.println("OK的话，准备办事");
    }
}
```

```java
public class Test{
    public static void main(String[] args){
        Zhangsan zhangsan = (Zhangsan) new CgglibMeipo().getInstance(Zhangsan.class);
        zhangsan.findLove();
    }
}
```



新的代理类需要去实现MethodInterceptor接口，并且重写`Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable `方法

==在代理类中要实现intercept：o：cglib生成的代理对象，method：被代理对象方法，objects：方法入参，methodProxy:代理方法==

![image-20210829181328226](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829181328.png)

> 现实中不会用到

> Cglib与JDK自带的最大的不同是，JDK需要去实现一个Person接口，因为newProxyInstance（）方法中需要有get Interface。
>
> 而Cglib底层是继承，方法都重写

![image-20210829195403787](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829195403.png)

继承父类生成字节码



## 动态代理实现原理

![image-20210829195830092](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829195830.png)

![image-20210829200011478](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829200011.png)



这样可以生成一个字节码

![image-20210829200930444](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829200930.png)

```java
public final class $Proxy0 extends Proxy implements IPerson {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m4;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void findLove() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void buyInsure() throws  {
        try {
            super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m3 = Class.forName("com.gupaoedu.vip.pattern.proxy.dynamicproxy.jdkproxy.IPerson").getMethod("findLove");
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m4 = Class.forName("com.gupaoedu.vip.pattern.proxy.dynamicproxy.jdkproxy.IPerson").getMethod("buyInsure");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```

 

看其中一个方法

![image-20210829202416316](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829202416.png)

![image-20210829202635510](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829202635.png)

此类事继承自Proxy的 去Proxy中找到h，这个h应该是protected的或者public的

![image-20210829202804667](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829202804.png)

查看Proxy类，发现在两处处赋予h值;发现有两处，1、在构造方法；2、在newProxyInstance方法中。这里显然是在第二处

![image-20210829202940651](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829202940.png)

![image-20210829210219506](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829210219.png)

![image-20210831102406451](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831102406.png)

最后调用有参构造，返回代理对象。

调用的构造方法是生成代理类对象的`public com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)`方法



从上面的类中可以看到

![image-20220426182619554](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202204261826704.png)

其实调用的是生成代理类的父类构造

![image-20220426182710328](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202204261827430.png)

因此可以得到

![image-20220426183037576](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202204261830690.png)

JdkMeipo中的getINstance返回的其实就是一个 代理类对象，其中这个对象是继承Proxy类里面的h变量就是JdkMeipo对象



因此`super.h.invoke(this,m3,(Object[])null)`调用的就是this代理类的方法。

这个方法中this就是代理生成的\$Proxy0类的对象；m3是什么在生成的\$Proxy0静态代码块就能看到。

![image-20210829212916504](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210829212916.png)

第三个参数是参数数组，因为findlove()是无参的所以是null。

此上可以得到实际就是调用 JdkMeipo对象的invoke增强方法。

![image-20220426184030111](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202204261840217.png)



***********

**Cglib中的动态代理**



System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,"cglib_proxy_classes");可以显示类；

```java
public class CglibTest {
    public static void main(String[] args) {

        try {
System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,"cglib_proxy_classes");

            Customer obj = (Customer) new CGlibMeipo().getInstance(Customer.class);
            System.out.println(obj);
            obj.findLove();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
```

运行后：

![image-20210830100833063](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830100833.png)

选中的就是生成的代理类，他继承了Customer类，并实现Factory接口。

![image-20210830101028162](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830101028.png)





在代理类中要实现intercept：sub：cglib生成的代理对象，method：被代理对象方法，objects：方法入参，methodProxy:代理方法。



实现了父类中的所有方法。而且每个方法都有一个MethodProxy对应。比如

![image-20210830221751131](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830221751.png)

上面举例的两个方法在代理类的findLove()方法中都有调用。

![image-20210830225607754](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830225607.png)

在代理类中

![image-20210830231220593](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830231220.png)

![image-20210830231057956](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830231058.png)

再多说一句，这里的MethodInterceptor对象就是我们用enhancer的setCallback方法传进来的。



返回来看`var10000.intercept(this, CGLIB$findLove$0$Method, CGLIB$emptyArgs, CGLIB$findLove$0$Proxy);`结合静态代码块，得到实际参数。==此时调用的intercept()方法就是我们代理类里写的经过强大的方法==；

![image-20210831000846844](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831000846.png)

```java
var10000.intercept(this, CGLIB$findLove$0$Method, CGLIB$emptyArgs, CGLIB$findLove$0$Proxy);

```

- this:就是代理生成对象本身；
- CGLIB\$findLove\$0\$Method：被代理的方法：==Method== CGLIB\$findLove\$0\$Method = ReflectUtils.findMethods(new String[]{"findLove", "()V"}, (var1=Class.forName("com.gupaoedu.vip.pattern.proxy.dynamicproxy.cglibproxy.Customer")).getDeclaredMethods())[0];
- CGLIB\$emptyArgs：函数调用的参数==Object[]== CGLIB\$emptyArgs = new Object[0];
- CGLIB\$findLove\$0\$Proxy：代理的方法：==MethodProxy== CGLIB\$findLove\$0\$Proxy = <font color = "red">MethodProxy</font>.create(var1, var0, "()V", "findLove", "CGLIB\$findLove$​​​​​​​0");



***<u>查看MethodProxy(重点)</u>***

![image-20210830233214201](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830233214.png)

查看代理方法的构造：var1就是我们被代理对象；var0就是代理对象本身；然后通过MethodProxy.create()方法创建一个MethodProxy，

![image-20210831001250391](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831001250.png)

==在MethodProxy源码中最主要的是invoke invokeSuper方法==（）

![image-20210831001848617](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831001848.png)

invoke中的fci.f1.invoke(fci.i1, obj, args);表示**用对象obj以参数args调用被代理类中函数描述为desc的name1方法**。

desc和name1是什么呢？再回过头看看MethodPeoxy的create()函数：

![image-20210831002001030](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831002001.png)

desc描述了这个函数的参数列表以及返回值，由于我们这里的say方法没有返回值且不接收参数，所以是()V。而name1则是函数在被代理类中的名字。



invokeSuper中的fci.f2.invoke(fci.i2, obj, args);就是直接调用CGLIB$findLove$0（）

> 两个方法调用通过FastClass？需要仔细看过，暂时没有



对方法的静态处理

```java
static void CGLIB$STATICHOOK1() {
    CGLIB$THREAD_CALLBACKS = new ThreadLocal();
    CGLIB$emptyArgs = new Object[0];
    Class var0 = Class.forName("com.gupaoedu.vip.pattern.proxy.dynamicproxy.cglibproxy.Customer$$EnhancerByCGLIB$$639fdb46");
    Class var1;
    CGLIB$findLove$0$Method = ReflectUtils.findMethods(new String[]{"findLove", "()V"}, (var1 = Class.forName("com.gupaoedu.vip.pattern.proxy.dynamicproxy.cglibproxy.Customer")).getDeclaredMethods())[0];
    CGLIB$findLove$0$Proxy = MethodProxy.create(var1, var0, "()V", "findLove", "CGLIB$findLove$0");
    Method[] var10000 = ReflectUtils.findMethods(new String[]{"finalize", "()V", "equals", "(Ljava/lang/Object;)Z", "toString", "()Ljava/lang/String;", "hashCode", "()I", "clone", "()Ljava/lang/Object;"}, (var1 = Class.forName("java.lang.Object")).getDeclaredMethods());
    CGLIB$finalize$1$Method = var10000[0];
    CGLIB$finalize$1$Proxy = MethodProxy.create(var1, var0, "()V", "finalize", "CGLIB$finalize$1");
    CGLIB$equals$2$Method = var10000[1];
    CGLIB$equals$2$Proxy = MethodProxy.create(var1, var0, "(Ljava/lang/Object;)Z", "equals", "CGLIB$equals$2");
    CGLIB$toString$3$Method = var10000[2];
    CGLIB$toString$3$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/String;", "toString", "CGLIB$toString$3");
    CGLIB$hashCode$4$Method = var10000[3];
    CGLIB$hashCode$4$Proxy = MethodProxy.create(var1, var0, "()I", "hashCode", "CGLIB$hashCode$4");
    CGLIB$clone$5$Method = var10000[4];
    CGLIB$clone$5$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Object;", "clone", "CGLIB$clone$5");
}
```



![image-20210831094913029](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831094913.png)

**总结**

==和被代理类中的方法完全重名的方法是用来给外部调用的，这个方法实际重写了被代理类（也就是父类）的方法。逻辑就是要把函数调用转发到intercept函数中，从而实现对被代理对象的代理！还有一个函数带有CGLIB前缀和标号（CGLIB$say$​0()），这个函数逻辑简单，就是直接调用被代理类的函数。也解释了为生命代理类中的intercept（）要用invokeSuper（）==





*******

### **两者的区别**

Cglib 继承的方式，覆盖父类的方法

JDK采用的实现方式，必须要求代理的目标对象一定要实现一个接口。

思想：都是通过生成字节码，重组成一个新类



JDK Proxy 对于用户而言，依赖更强，调用也会更复杂

Cglib 对目标没有要求。



Cglib 效率更高，性能更高，底层没有用到反射

JDK Proxy 生成逻辑较为简单，执行效率要低，每次都要用反射。



JDKlib 有个坑：目标代理类不能有final的方法，忽略final修饰的方法。不能代理final方法



## 静动态代理的本质区别

1、静态代理只能通过手动完成代理操作，如果被代理类增加了新方法，代理类需要同步增加，违背开闭原则。

2、动态代理采用运行时动态生成代码的方式，取消了对被动态代理类的扩展限制，遵循开闭原则。

3、若动态代理要对目标类的增强逻辑进行扩容，结合策略模式，只需要新增策略类便可完成，无需修改代理类代码。

>动态代理和静态代理相比较，最大的好处就是接口中声明的所有的方法都被转移到一个集中的方法中去处理，例如invocke()方法。这样在接口中声明的方法比较多的情况下我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。



## 代理模式的优缺点

优点：

1、代理模式能将代理对象与真实被调用的目标对象分离

2、一定程度上降低了系统的耦合程度，易于扩展

3、代理可以起到保护目标对象的作用。

4、增强目标对象的职责。



缺点：

1、代理模式会造成系统设计中类的数目增加

2、在客户端和目标对象之间增加了一个代理对象，请求速度变慢。

3、增加了系统的复杂度。





## 手搓动态代理

代理类需要实现InvocationHandler接口，在InvocationHandler接口中只有一个方法。

```Java
import java.lang.reflect.Method;

public interface ZYHInvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable;
}
```

```java
package com.gupaoedu.vip.pattern.proxy.dynamicproxy.ZYHProxy.proxy;

import com.gupaoedu.vip.pattern.proxy.dynamicproxy.gpproxy.proxy.GPInvocationHandler;
import jdk.nashorn.internal.runtime.FindProperty;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.File;
import java.io.FileWriter;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.URLDecoder;

/**
 * @Package: com.gupaoedu.vip.pattern.proxy.dynamicproxy.ZYHProxy
 * @ClassName: ZYHProxy
 * @Author: zyh
 * @CreateTime: 2021/8/29 9:52 下午
 * @Description:
 */
public class ZYHProxy {

    public static final String ln ="\r\n";

    public static Object newProxyInstance(ZYHClassLoader loader,
                                          Class<?>[] interfaces,
                                          ZYHInvocationHandler h)
            throws IllegalArgumentException {

        try {
            //1、东动态生成源码.java文件（其实是一个字符串到过程）
            String src = generateSrc(interfaces);
            System.out.println("=====");
            System.out.println(src);

            //2、Java文件输出到磁盘，保存为文件$Proxy0.java
            String filePath = URLDecoder.decode(ZYHProxy.class.getResource("").getPath(),"UTF-8");
            File f = new File(filePath + "$Proxy0.java");
            FileWriter fw = new FileWriter(f);
            fw.write(src);
            fw.flush();
            fw.close();

            //3、把.java文案编译成$Prosxy0.class文件
            JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
            StandardJavaFileManager manage = compiler.getStandardFileManager(null,null,null);
            Iterable iterable = manage.getJavaFileObjects(f);

            JavaCompiler.CompilationTask task = compiler.getTask(null,manage,null,null,null,iterable);
            task.call();
            manage.close();

            //4、把生成分到.class文件加载到JVM中
            Class proxyClass =  loader.findClass("$Proxy0");
            Constructor c = proxyClass.getConstructor(GPInvocationHandler.class);
            f.delete();

            //5、返回新到代理对象
            return c.newInstance(h);
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

    private static String generateSrc(Class<?>[] interfaces) {
        StringBuilder sb = new StringBuilder();
        sb.append("package com.gupaoedu.vip.pattern.proxy.dynamicproxy.ZYHProxy.proxy;"+ln);
        sb.append("import com.gupaoedu.vip.pattern.proxy.dynamicproxy.ZYHProxy.client.IPerson;" + ln);
        sb.append("import java.lang.reflect.*;"+ln);
        sb.append("public class $Proxy0 implements " + interfaces[0].getName()+"{"+ln);

        sb.append("ZYHInvocationHandler h;" + ln) ;
        sb.append("public $Proxy0(ZYHInvocationHandler h){" + ln);
            sb.append("this.h = h;"+ln);
        sb.append("}"+ln);

        for (Method m : interfaces[0].getMethods()){
            Class<?> [] params = m.getParameterTypes();

//            StringBuilder paramNames = new StringBuilder();
//            StringBuilder paramValues = new StringBuilder();
//            StringBuilder paramClasses = new StringBuilder();

//            for (int i = 0;i<params.length;i++){
//                Class clazz = params[i];
//                String type = clazz
//            }

            sb.append("public " + m.getReturnType().getName()+" " + m.getName()+"(){"+ln);
                sb.append("try{" + ln);
                    sb.append("Method m =" + interfaces[0].getName() + ".class.getMethod(\""+m.getName()+"\",new Class[]{});"+ln);
                    sb.append("this.h.invoke(this,m,new Object[]{});"+ln);
                    sb.append("return;"+ln);
                sb.append("}catch(Error _ex) { }");
                sb.append("catch(Throwable e){" + ln);
                sb.append("throw new UndeclaredThrowableException(e);" + ln);
                sb.append("}");
            sb.append("}"+ln);
        }


        sb.append("}");
        return  sb.toString();
    }

}
```

```java
package com.gupaoedu.vip.pattern.proxy.dynamicproxy.ZYHProxy.proxy;

import com.gupaoedu.vip.pattern.proxy.dynamicproxy.gpproxy.proxy.GPClassLoader;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;

/**
 * @Package: com.gupaoedu.vip.pattern.proxy.dynamicproxy.ZYHProxy
 * @ClassName: ZYHClassLoader
 * @Author: zyh
 * @CreateTime: 2021/8/29 9:53 下午
 * @Description:
 */
public class ZYHClassLoader extends ClassLoader{

    private File classPathFile;

    public ZYHClassLoader(){
        String classPath = GPClassLoader.class.getResource("").getPath();
        this.classPathFile = new File(classPath);
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {

        String className = GPClassLoader.class.getPackage().getName() + "." + name;
        if(classPathFile  != null){
            File classFile = new File(classPathFile,name.replaceAll("\\.","/") + ".class");
            if(classFile.exists()){
                FileInputStream in = null;
                ByteArrayOutputStream out = null;
                try{
                    in = new FileInputStream(classFile);
                    out = new ByteArrayOutputStream();
                    byte [] buff = new byte[1024];
                    int len;
                    while ((len = in.read(buff)) != -1){
                        out.write(buff,0,len);
                    }
                    return defineClass(className,out.toByteArray(),0,out.size());
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }
        return null;
    }
}
```



## 代理模式在Spring

### 代理模式在Spring中的应用

ProxyFactoryBean核心方法 getObject(),

![image-20210830124920614](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210830124920.png)

主要调用getSingletonInstance()和newPrototypeInstance（）。在spring的配置中如果不做任何配置，那么Spring代理生成的Bean就都是单例的。、

Spring 利用动态代理实现AOP时有两个非常重要的类：JdkDynamicAopProxy类和CglibAopProxy类。



### Spring代理模式的选择

1、当Bean有实现接口，Spring就会用JDK动态代理

2、当Bean没有实现接口，Spring会选择CGLib代理

3、Spring可以通过配置强制使用CHLib，只需在Spring的配置文件中加入如下代码。

```properties
<aop:aspectj-autoproxy proxy-target-class="true"/>
```





# 适配器模式(Adapter Pattern)

定义：又叫变压器模式，它的功能是将一个类的接口变成客户端的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作。

属于结构型设计模式。



## 适用场景

1、已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。

2、适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。



## 通用写法

适配器一般包含三种角色：

目标角色（Target）：也就是我们期望的接口；

源角色（Adaptee）：存在于系统中，内容满足客户需求（需转换），但接口不匹配的接口实例；

适配器（adapter）：将原角色（Adaptee）转化为目标角色（Target）的类实例；



适配器一般后三种形式：类适配器、对象适配器、接口适配器。

***********

**类适配器**

![image-20210831215233222](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831215233.png)

让Adapter实现Target接口，并且继承Adaptee。在Target方法内实现转换。

例子：在中国民用电都是220V交流电，但手机是5V直流电。因此我们需要给手机使用电源适配器来转换。

```java
public class AC220 {
    public int outputAC220V(){
        int output = 220;
        System.out.println("输出电压" + output + "V");
        return output;
    }
}
```

```java
public interface DC5 {
    int output5V();
}
```

```java
public class PowerAdapter extends AC220 implements DC5 {
    public int output5V() {
        int adapterInput = super.outputAC220V();
        int adapterOutput = adapterInput / 44;
        System.out.println("使用Adapter输入AC" + adapterInput + "V,输出DC" + adapterOutput + "V");
        return adapterOutput;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        DC5 adapter = new PowerAdapter();
        adapter.output5V();
    }
}
```

*************

**对象适配器**

类适配器违背最少知道原则。![image-20210831225638987](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210831225639.png)

与类适配器相比，是通过组合的方式来实现。让Adapter实现Target接口，然后内部持有Adaptee实例，然后在Target接口规定的方法内转换Adaptee。

```java
public class PowerAdapter implements DC5 {
    private AC220 ac220;

    public PowerAdapter(AC220 ac220) {
        this.ac220 = ac220;
    }

    public int output5V() {
        int adapterInput = ac220.outputAC220V();
        int adapterOutput = adapterInput / 44;
        System.out.println("使用Adapter输入AC" + adapterInput + "V,输出DC" + adapterOutput + "V");
        return adapterOutput;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        DC5 adapter = new PowerAdapter(new AC220());
        adapter.output5V();
    }
}
```

*************

**接口适配器**

接口适配器与前面两种的关注点不同，类适配器和对象适配器着重于将系统存在的一个角色（Adaptee）转化成目标接口（Target）所需的内容，而接口适配器的使用场景是解决接口方法过多，只需要去实现我们需要实现的方法。

```java
public interface DC {
    int output5V();
    int output12V();
    int output24V();
    int output36V();
}
```

```java
public class PowerAdapter implements DC {
    private AC220 ac220;

    public PowerAdapter(AC220 ac220) {
        this.ac220 = ac220;
    }

    public int output5V() {
        int adapterInput = ac220.outputAC220V();
        int adapterOutput = adapterInput / 44;
        System.out.println("使用Adapter输入AC" + adapterInput + "V,输出DC" + adapterOutput + "V");
        return adapterOutput;
    }

    public int output12V() {
        return 0;
    }

    public int output24V() {
        return 0;
    }

    public int output36V() {
        return 0;
    }
}
```

原理：利用抽象类实现接口，并且空实现接口众多方法。

## 多种方式登陆

```java
public class PassportService {

    /**
     * 注册方法
     * @param username
     * @param password
     * @return
     */
    public ResultMsg regist(String username,String password){
        return  new ResultMsg(200,"注册成功",new Member());
    }

    /**
     * 登录的方法
     * @param username
     * @param password
     * @return
     */
    public ResultMsg login(String username,String password){
        return null;
    }

}
```

要用优雅的方式，创建不同登陆方式的Adapter

首先建立一个LoginAdapter接口

```java
public interface ILoginAdapter {
    boolean support(Object object);
    ResultMsg login(String id,Object adapter);
}
```

然后实现不同方式登陆的适配器

```java
public class LoginForQQAdapter extends AbstraceAdapter{
    public boolean support(Object adapter) {
        return adapter instanceof LoginForQQAdapter;
    }

    public ResultMsg login(String id, Object adapter) {
        if(!support(adapter)){return null;}
        //accesseToken
        //time
        return super.loginForRegist(id,null);

    }

}
```

supprot()方法用来判断是否兼容







## 适配器在源码中的体现

在Spring中：SpringAOP中的AdvisorAdapter类，有三个实现类MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter和ThrowsAdviceAdapter，

```java
public interface AdvisorAdapter {
    boolean supportsAdvice(Advice var1);

    MethodInterceptor getInterceptor(Advisor var1);
}
```

```java
class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {
    MethodBeforeAdviceAdapter() {
    }

    public boolean supportsAdvice(Advice advice) {
        return advice instanceof MethodBeforeAdvice;
    }

    public MethodInterceptor getInterceptor(Advisor advisor) {
        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();
        return new MethodBeforeAdviceInterceptor(advice);
    }
}
```

springMVC中的HandlerAdapter类，

```java
public interface HandlerAdapter {
    boolean supports(Object var1);

    @Nullable
    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;

    long getLastModified(HttpServletRequest var1, Object var2);
}
```

```java
public class HttpRequestHandlerAdapter implements HandlerAdapter {
    public HttpRequestHandlerAdapter() {
    }

    public boolean supports(Object handler) {
        return handler instanceof HttpRequestHandler;
    }

    @Nullable
    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        ((HttpRequestHandler)handler).handleRequest(request, response);
        return null;
    }

    public long getLastModified(HttpServletRequest request, Object handler) {
        return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;
    }
}
```



## 适配器模式的优缺点

优点：

1、能提高类的透明性和复用，现有类复用但不需要改变。

2、目标类和适配器节藕，提高程序的扩展性。

3、符合开闭原则，比如上面的多种方式登陆，如果在未来有新的方式出现，只需要去创建新的adapter就行



缺点：

1、编写需要全面的考虑，可能会增加系统的复杂性

2、增加代码阅读难度。



# 桥接模式（Bridge Pattern）

定义：也称桥梁模式、接口模式或柄体模式，是将抽象部分与它的具体实现部分分离，使他们可以独立的变化

通过组合的方式建立两个类之间的联系，而不是继承

属于结构型模式。



## 适用场景

1、在抽象个具体实现之间需要增加更多的灵活性的场景。

2、一个类存在两个（或多个）独立变化的维度，而这两个（或多个）维度都需要独立进行扩展。

3、不希望使用继承，或因为多层继承导致系统类的个数剧增。



## 通用写法



![image-20210902225941324](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902225947.png)

包含四种角色

抽象（Abstraction）：该类持有一个对实现角色的引用，抽象角色中的方法需要实现角色来实现。抽象角色一般为抽象类（构造函数规定子类要传入一个实现对象）

修正抽象（RefinedAbstract）:Abstract的具体实现，对Abstraction的方法进行完善和扩展；

实现（Implementor）：确定实现维度的基本操作，提供给Abstraction使用。该类一般为接口或抽象类；

具体实现（ConcreteImplementor）：Implementor的具体实现

```java
// 抽象
public abstract class Abstraction {

    protected IImplementor mImplementor;

    public Abstraction(IImplementor implementor) {
        this.mImplementor = implementor;
    }

    public void operation() {
        this.mImplementor.operationImpl();
    }
}
```

```java
// 修正抽象
public class RefinedAbstraction extends Abstraction {
    public RefinedAbstraction(IImplementor implementor) {
        super(implementor);
    }

    @Override
    public void operation() {
        super.operation();
        System.out.println("refined operation");
    }
}
```

```java
// 抽象实现
public interface IImplementor {
    void operationImpl();
}
```

```java
// 具体实现
public class ConcreteImplementorA implements IImplementor {

    public void operationImpl() {
        System.out.println("I'm ConcreteImplementor A");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 来一个实现化角色
        IImplementor imp = new ConcreteImplementorA();
        // 来一个抽象化角色，聚合实现
        Abstraction abs = new RefinedAbstraction(imp);
        // 执行操作
        abs.operation();
    }
}
```



## 应用场景

场景一：有许多课程：java AI 测试等，每个课又都有笔记Note、视屏Video

![image-20210902232125365](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902232125.png)

![image-20210902232332576](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902232332.png)

原来分为两个继承体系 NOte Video

AbstractCourse就是交接类。





场景二：消息，消息可以分为邮件消息、短信消息和系统内部消息。按紧急程度分为普通、紧急、特急;

如果用继承的话情况就复杂也不利于扩展。邮件可以是普通的，也可以是紧急的；短信可以是普通的，也可以是紧急的。

![image-20210902232653662](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902232653.png)

![image-20210902232720632](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902232720.png)



首先创建一个IMessage接口担任桥接的角色

```java
//抽象实现
public interface IMessage {
    //发送消息的内容和接收人
    void send(String message,String toUser);
}
```

创建邮件消息实现EmailMessage类

```java
public class EmailMessage implements IMessage {
    public void send(String message, String toUser) {
        System.out.println("使用邮件消息发送" + message + "给" + toUser);
    }
}
```

手机短信

```java
public class SmsMessage implements IMessage {
    public void send(String message, String toUser) {
        System.out.println("使用短信消息发送" + message + "给" + toUser);
    }
}
```



然后去创建桥接抽象角色AbstractMessage

```java
public abstract class AbastractMessage {
    private IMessage message;

    public AbastractMessage(IMessage message) {
        this.message = message;
    }
    void sendMessage(String message,String toUser){
        this.message.send(message,toUser);
    }
}


```

加急类重写发送方法，普通不用

```java
public class UrgencyMessage extends AbastractMessage {
    public UrgencyMessage(IMessage message) {
        super(message);
    }

    void sendMessage(String message, String toUser){
        message = "【加急】" + message;
        super.sendMessage(message,toUser);
    }

    public Object watch(String messageId){
        return null;
    }
}
```

```java
public class NomalMessage extends AbastractMessage {
    public NomalMessage(IMessage message) {
        super(message);
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        IMessage message = new SmsMessage();
        AbastractMessage abastractMessage = new NomalMessage(message);
        abastractMessage.sendMessage("加班申请","王总");

        message = new EmailMessage();
        abastractMessage = new UrgencyMessage(message);
        abastractMessage.sendMessage("加班申请","王总");
    }

}
```

![截屏2021-09-02 下午11.39.55](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902234432.png)





## 在源码中的应用

在JDBC API中，有一个driver类，我们可以通过Class.forName()方法可以动态加载各个数据库厂商实现的Driver类



```java
//1.加载驱动
Class.forName("com.mysql.jdbc.Driver");  //反射机制加载驱动类
// 2.获取连接Connection
//主机:端口号/数据库名
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "root");
// 3.得到执行sql语句的对象Statement
Statement stmt = conn.createStatement();
// 4.执行sql语句，并返回结果
ResultSet rs = stmt.executeQuery("select *from table");
```

查看com.mysql.jdbc.Driver类![截屏2021-09-02 下午11.49.51](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902235047.png)

![image-20210902235130684](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902235130.png)

当Class.forName("com.mysql.jdbc.Driver")找到类，就会去执行里面的静态代码。

![image-20210902235544353](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210902235544.png)

![截屏2021-09-02 下午11.56.27](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903000033.png)

存入registeredDrivers变量中

![image-20210903000221742](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903000221.png)



第二步获取连接

![image-20210903001119984](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903001120.png)

但是在Mysql的driver中没有这个方法，去看父类NonRegisteringDriver

![image-20210903001501439](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903001501.png)

包装成一个mysql的Connection返回

![image-20210903001645456](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903001645.png)

mysql的connection实现jdk的connection

这样在test中可以用jdk的connection来接收

![image-20210903001904570](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903001904.png)



## 桥接模式优缺点

优点：

1、分离了抽象部分及其具体实现部分

2、提高系统扩展性

3、符合开闭 

4、符合合成复用



缺点：

1、增加了系统的理解难度

2、需要正确的识别系统中两个独立变化的维度。



# 享元模式（Flyweight Pattern）

定义：又被称为轻量级模式，是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构方式。

宗旨：共享细粒度对象，将多个对同一对象的访问集中起来。

属于结构型模式。



## 通用写法

享元模式把一个对象的状态分为内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后痛殴不变的部分，达到减少对象数量并节约内存的目的。

![image-20210903222325005](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210903222325.png)

抽象享元角色（Flyweight）：享元对象抽象基类或者接口，同时定义出对象的外部状态和内部状态的接口或实现；(就是我们原来需要反复创建的对象)

具体享元角色（ConcreteFlyweight）：实现抽象角色定义的业务。该角色的内部状态处理应该与环境无关，不能出现会有一个操作改变内部状态，同时修改了外部状态；

享元工厂（FlyweightFactory）：负责管理享元对象池和创建享元对象。

```java
// 抽象享元角色
public interface IFlyweight {
    void operation(String extrinsicState);
}
```

```java
// 具体享元角色
public class ConcreteFlyweight implements IFlyweight {
    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }


    public void operation(String extrinsicState) {
        System.out.println("Object address: " + System.identityHashCode(this));
        System.out.println("IntrinsicState: " + this.intrinsicState);
        System.out.println("ExtrinsicState: " + extrinsicState);
    }
}
```

```java
// 享元工厂
public class FlyweightFactory {
  //pool就是缓存
    private static Map<String, IFlyweight> pool = new HashMap<String, IFlyweight>();

    // 因为内部状态具备不变性，因此作为缓存的键
    public static IFlyweight getFlyweight(String intrinsicState) {
        if (!pool.containsKey(intrinsicState)) {
            IFlyweight flyweight = new ConcreteFlyweight(intrinsicState);
            pool.put(intrinsicState, flyweight);
        }
        return pool.get(intrinsicState);
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        IFlyweight flyweight1 = FlyweightFactory.getFlyweight("aa");
        IFlyweight flyweight2 = FlyweightFactory.getFlyweight("bb");
        flyweight1.operation("a");
        flyweight2.operation("b");
    }
}
```





## 适用场景

常常用于系统底层的开发，以便解决系统的性能问题。

系统有大量相似对象、需要缓冲池的场景。



场景一：抢票

比如要求通过出发站，目的站查火车票的相关信息，那么我们只需要构建出火车票类对象，然后提供一个查询出发站，目的站的接口给到科技进行查询即可。

```java
//ITicket接口
public interface ITicket {
    void showInfo(String bunk);
}
```

然后创建ITicket接口的实现类，TrainTicket

```java
//TrainTicket
public class TrainTicket implements ITicket {
    private String from;
    private String to;
    private int price;

    public TrainTicket(String from, String to) {
        this.from = from;
        this.to = to;
    }


    public void showInfo(String bunk) {
        this.price = new Random().nextInt(500);
        System.out.println(String.format("%s->%s：%s价格：%s 元", this.from, this.to, bunk, this.price));
    }
}
```

最后创建一个享元工厂TicketFactory;增加一个缓存机制，创建一个pool map用来存放余票的对象。

```java
class TicketFactory {
    private static Map<String, ITicket> sTicketPool = new ConcurrentHashMap<String,ITicket>();

    public static ITicket queryTicket(String from, String to) {
        String key = from + "->" + to;
        if (TicketFactory.sTicketPool.containsKey(key)) {
            System.out.println("使用缓存：" + key);
            return TicketFactory.sTicketPool.get(key);
        }
        System.out.println("首次查询，创建对象: " + key);
        ITicket ticket = new TrainTicket(from, to);
        TicketFactory.sTicketPool.put(key, ticket);
        return ticket;
    }
}
```

![image-20210904104306205](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904104306.png)



场景二：线程池

```java
public class ConnectionPool {

    private Vector<Connection> pool;

    private String url = "jdbc:mysql://localhost:3306/test";
    private String username = "root";
    private String password = "root";
    private String driverClassName = "com.mysql.jdbc.Driver";
    private int poolSize = 100;

    public ConnectionPool() {
        pool = new Vector<Connection>(poolSize);

        try{
            Class.forName(driverClassName);
            for (int i = 0; i < poolSize; i++) {
                Connection conn = DriverManager.getConnection(url,username,password);
                pool.add(conn);
            }
        }catch (Exception e){
            e.printStackTrace();
        }

    }

    public synchronized Connection getConnection(){
        if(pool.size() > 0){
            Connection conn = pool.get(0);
            pool.remove(conn);
            return conn;
        }
        return null;
    }

    public synchronized void release(Connection conn){
        pool.add(conn);
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        ConnectionPool pool = new ConnectionPool();
        Connection conn = pool.getConnection();
        System.out.println(conn);
    }
}
```



## 在源码中的体现

 **String**

```java
public class StringTest {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = "he" + "llo";
        String s4 = "hel" + new String("lo");
        String s5 = new String("hello");
        String s6 = s5.intern();
        String s7 = "h";
        String s8 = "ello";
        String s9 = s7 + s8;
        System.out.println(s1==s2);//true
        System.out.println(s1==s3);//true
        System.out.println(s1==s4);//false
        System.out.println(s1==s9);//false
        System.out.println(s4==s5);//false
        System.out.println(s1==s6);//true
      	System.out.println(s1==s8+s9);//false
    }
}
```

String类由final修饰，以字面量的形式创建String变量时，JVM会在编译期间就把该字面量“hello”放到字符串常量池中，由Java程序启动时就已经加载到内存中了。字符串常量池的特点就是有且只有一份相同的字面量，如果有相同的字面量，JVM就会返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。

S1 == S3:s3字面量其实就是hello，JVM在编译期间就已经对他进行优化，所以s1和s3也是相等的。

s4中的new String("lo")生成了两个对象，lo，new String("lo")，lo存在字符串常量池，new String("lo")存在堆中，String s4 = ”“hel”+new String("lo")实质上是两个对象的相加，==编译器不会进行优化，相加的结果存在堆中==，而s1存在字符串常量池中，当然不相等。s1==s9一样

s1==s6，s5.intern()方法能使一个位于堆中的字符串在运行期间动态地加入到字符串常量池中（字符串常量池是程序启动的时候就已经记载好了），如果字符串常量池中有该对象对应的字面量，则返回字面量在字符串在常量池中的引用，否则，创建复制一份该字符串常量池并返回它的引用。



**Integer**

![image-20210904113219691](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904113219.png)

![image-20210904113518947](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904113519.png)

![image-20210904114057175](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904114057.png)

> Integer源码中的valueOf（）方法做了一个条件判断，如果目标值在-128-127之间，就直接在缓存中取值，否则创建新对象。因为-128到127之间到数据在int范围内使用最频繁。使用享元模式来提高性能。



**Long**

![image-20210904114527086](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904114527.png)



**Apache Commons Pool2 中的享元模式**

对象池

![image-20210904115348623](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904115348.png)

找一个实现类

![image-20210904115532691](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904115532.png)

## 扩展知识

内部状态值对象共享出来的信息，存储在享元对象内部并且不会随环境改变而改变的；外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

比如，连接池中的连接对象，保存在里面的用户名、密码、url等信息，这些是不会改变的，这些是内部状态。每个连接要回收利用，我们分配一个变量作为标记是否为可用状态，这些是外部状态。



## 享元模式的优缺点

优点：

1、减少对象的创建，降低内存中的对象数量，降低系统的内存（在创建的过程中要调用接口、端口，会占用内存），提高效率

2、减少内存之外的其他资源占用

缺点：

1、关注内外部状态，关注线程安全问题

2、使系统、程序的逻辑复杂化（比如Integer a==127 万一传过来128）



享元：控制不要过分消耗资源

代理：功能增强

一般享元和工厂一起使用，享元工厂一般设计成单例





# 组合模式（Composite pattern）

定义：也称为整体-部分（Part-Whole）模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示。

作用：使客户端对单个对象和组合对象保持一致的处理方式。



组合关系：具有相同的生命周期

聚合关系：具有不同的生命周期

## 适用场景

1、希望客户端可以忽略组合对象与单个对象的差异

2、对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）



## 透明组合模式的写法

组合模式包含3个角色：

1、抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性

2、树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构；

3、叶子节点（leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。



**透明组合模式**

把所有公共方法都定义在Component中，这样的好处是无需分辨叶子节点（Leaf）和树枝节点（Composite），他们具备完全一致的接口。

![image-20210904154123876](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904154124.png)

Leaf就是只实现一部分部门 其他都是空实现在Component。要实现的就去覆盖掉父类方法



## 安全组合模式

只规定系统各个层次的最基础的一致性行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身中。

![image-20210904154851279](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904154851.png)



## 业务场景

课程



**透明写法**

```java
//抽象根节点
public abstract class CourseComponent {

    public void addChild(CourseComponent catalogComponent){
        throw new UnsupportedOperationException("不支持添加操作");
    }

    public void removeChild(CourseComponent catalogComponent){
        throw new UnsupportedOperationException("不支持删除操作");
    }


    public String getName(CourseComponent catalogComponent){
        throw new UnsupportedOperationException("不支持获取名称操作");
    }


    public double getPrice(CourseComponent catalogComponent){
        throw new UnsupportedOperationException("不支持获取价格操作");
    }


    public void print(){
        throw new UnsupportedOperationException("不支持打印操作");
    }

}
```

```java
//叶节点
public class Course extends CourseComponent {
    private String name;
    private double price;

    public Course(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String getName(CourseComponent catalogComponent) {
        return this.name;
    }

    @Override
    public double getPrice(CourseComponent catalogComponent) {
        return this.price;
    }

    @Override
    public void print() {
        System.out.println(name + " (￥" + price + "元)");
    }

}
```

```java
//树枝节点
public class CoursePackage extends CourseComponent {
    private List<CourseComponent> items = new ArrayList<CourseComponent>();
    private String name;
    private Integer level;


    public CoursePackage(String name, Integer level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void addChild(CourseComponent catalogComponent) {
        items.add(catalogComponent);
    }

    @Override
    public String getName(CourseComponent catalogComponent) {
        return this.name;
    }

    @Override
    public void removeChild(CourseComponent catalogComponent) {
        items.remove(catalogComponent);
    }

    @Override
    public void print() {
        System.out.println(this.name);

        for(CourseComponent catalogComponent : items){
            //控制显示格式
            if(this.level != null){
                for(int  i = 0; i < this.level; i ++){
                    //打印空格控制格式
                    System.out.print("  ");
                }
                for(int  i = 0; i < this.level; i ++){
                    //每一行开始打印一个+号
                    if(i == 0){ System.out.print("+"); }
                    System.out.print("-");
                }
            }
            //打印标题
            catalogComponent.print();
        }
    }

}
```

```java
public class Test {
    public static void main(String[] args) {

        System.out.println("============透明组合模式===========");

        CourseComponent javaBase = new Course("Java入门课程",8280);
        CourseComponent ai = new Course("人工智能",5000);

        CourseComponent packageCourse = new CoursePackage("Java架构师课程",2);

        CourseComponent design = new Course("Java设计模式",1500);
        CourseComponent source = new Course("源码分析",2000);
        CourseComponent softSkill = new Course("软技能",3000);

        packageCourse.addChild(design);
        packageCourse.addChild(source);
        packageCourse.addChild(softSkill);

        CourseComponent catalog = new CoursePackage("课程主目录",1);
        catalog.addChild(javaBase);
        catalog.addChild(ai);
        catalog.addChild(packageCourse);

        catalog.print();


    }
}
```





**安全模式**

场景：操作系统文件系统

```java
//抽象根目录
public abstract class Directory {

    protected String name;

    public Directory(String name) {
        this.name = name;
    }

    public abstract void show();

}
```

```java
//定义文件夹
public class Folder extends Directory {
    private List<Directory> dirs;

    private Integer level;

    public Folder(String name,Integer level) {
        super(name);
        this.level = level;
        this.dirs = new ArrayList<Directory>();
    }

    @Override
    public void show() {
        System.out.println(this.name);
        for (Directory dir : this.dirs) {
            //控制显示格式
            if(this.level != null){
                for(int  i = 0; i < this.level; i ++){
                    //打印空格控制格式
                    System.out.print("  ");
                }
                for(int  i = 0; i < this.level; i ++){
                    //每一行开始打印一个+号
                    if(i == 0){ System.out.print("+"); }
                    System.out.print("-");
                }
            }
            //打印名称
            dir.show();
        }
    }

    public boolean add(Directory dir) {
        return this.dirs.add(dir);
    }

    public boolean remove(Directory dir) {
        return this.dirs.remove(dir);
    }

    public Directory get(int index) {
        return this.dirs.get(index);
    }

    public void list(){
        for (Directory dir : this.dirs) {
            System.out.println(dir.name);
        }
    }

}
```

```java
//定义文件
public class File extends Directory {

    public File(String name) {
        super(name);
    }

    @Override
    public void show() {
        System.out.println(this.name);
    }

}
```

```java
class Test {
    public static void main(String[] args) {

        System.out.println("============安全组合模式===========");

        File qq = new File("QQ.exe");
        File wx = new File("微信.exe");

        Folder office = new Folder("办公软件",2);

        File word = new File("Word.exe");
        File ppt = new File("PowerPoint.exe");
        File excel = new File("Excel.exe");

        office.add(word);
        office.add(ppt);
        office.add(excel);

        Folder wps = new Folder("金山软件",3);
        wps.add(new File("WPS.exe"));
        office.add(wps);

        Folder root = new Folder("根目录",1);
        root.add(qq);
        root.add(wx);
        root.add(office);

        System.out.println("----------show()方法效果-----------");
        root.show();

        System.out.println("----------list()方法效果-----------");
        root.list();


    }
}
```

如果不用组合 可能会出现

![image-20210904161701937](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904161702.png)

用了组合通过level去控制层级。



## 在源码中的体现

**HashMap**

其中的putAll（）方法，参数是直接一个map类型，map是一个抽象构件，HashMap是一个中间构建，Node就是叶子节点，而不是一个list\<key\> 和list\<value\>,而是在内部进行循坏

![image-20210904161918713](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904161918.png)

![截屏2021-09-04 下午4.21.30](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904162200.png)

![image-20210904163256412](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904163256.png)



**ArrayList**

中的addAll（），参数也是ArrayList的父类Collection

![image-20210904163325190](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904163325.png)



**Mybatis中的SqlNode**

![image-20210904163549701](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904163549.png)

![image-20210904163616151](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20210904163616.png)

xml中的每一个Node都会解析为一个SqlNode对象，最后把所有的SqlNode拼装到一起就形成了一条完整的SQL“语句。

Apply()方法会更具传入的参数，参数解析该SqlNode所记录的SQL片段，并调用DynamicContext.appendSql（）方法将解析后的SQl片段追加到DynamicContext的sqlBuilder中保存。



## 优缺点

系统各个节点差异性不大，可以使用透明的写法，

如果差异较大，且不太修改，使用安全的写法

优点：

1、清楚的定义分层次的复杂对象，表示对象的全部或部分层次

2、让客户端忽略了层次的差异，方便对整个层次结构进行控制

3、简化客户端代码（不需要一层层的去嵌套）

4、符合开闭原则



缺点：

1、限制类型时会较为复杂

2、使设计变得更加抽象。





# 委派模式（Delegate Pattern）

委派模式又叫委托模式。基本作用就是负责任务的调度和任务的分配，将任务的分配和执行分离开来。可以看作是一种特殊情况下的静态代理的全权代理。

不属于GOF 23种设计模式之一

属于行为型模式。



## 应用场景

1、委派对象本身不知道该如何处理一个任务（或一个请求），把请求交给其他对象来处理

2、实现程序的结偶



> 可以理解为自己不擅长工作的老板，会雇佣技术好的员工来工作





![image-20211208113232926](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081132671.png)

抽象任务色(Task) :定义一个抽象接口,它有若干实现类。
委派者角色(Delegate) :负责在各个具体角色实例之间做出决策并判断并调用具体实现的方法。
具体任务色(Concrete) 真正执行任务的色。



## 在源码中的体现

1、JDK中有一个典型的委派，JVM在加载类是用的双亲委派模型；一个类加载器在加载类时，先把这个请求委派给自己的父类加载器去执行，如果父类加载器还存在父类加载器,就继续向上委派，直到顶层的启动类加载器。如果父类加载器能够完成类加载,就成功返回,如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。从定义中可以看到双亲加载模型一个类加载器加载类时，首先不是自己加载，而是委派给父加载器。下面我们来看看loadClass(方法的源码，此方法在ClassLoader中。在这个类里就定义了一个双亲，用于下面的类加载。

![image-20211208113536663](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081135529.png)



2、在Method类中的invoke方法

![image-20211208113714907](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081137662.png)



3、Spring Ioc中的DefaultBeanDefinitionDocumentReader 中的doRegisterBeanDefinitions方法中

![image-20211208113908387](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081139482.png)

![image-20211208113954210](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081139968.png)



4、springMVC中的dispatcher也是同样如此

![image-20211208114226244](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081142415.png)



## 委派模式的优缺点

### 优点:、

通过任务委派能够将一个大型的任务细化， 然后通过统一管理这些子任务的完成情况实现任务的跟
进，能够加快任务执行的效率。

### 缺点: .

任务委派方式需要根据任务的复杂程度进行不同的改变,在任务比较复杂的情况下可能需要进行多
重委派，容易造成紊乱。



## 委派模式和代理模式的区别

1、委派模式是行为形模式。代理模式是结构模式

2、委派模式注重的是任务委派，注重结果；代理模式是代码增强，注重过程

3、委派模式是一种特殊的静态代理，相当于全权代理。



# 模板方法模式

t通常又叫模板模式，定义一个算法骨架，并允许子类为其中一个或者多个步骤提供实现

模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤

属于行为形设计模式

 



## 应用场景

当有一个操作具有固定流程时，由抽象固定流程步骤，具体步骤交给子类进行具体实现

![image-20211208115455665](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081154251.png)

抽象模板：抽象模板类，定义了一套算法框架/流程;其中的templateMethod方法定义了step1、step2、step3的执行顺序。step方法的具体实现由子类自行定义

具体实现：具体实现类



![image-20211208140749753](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112081407595.png)





# 策略模式

政策模式，将定义的算法家族分别封装起来，让他们之间可以相互替换，从而让算法的变化不会影响到使用算法的用户。

可以避免多重分支 if...else 和 switch

属于行为形模式



## 适用场景 

1、假如系统中有很多类，而他们的区别仅仅在于他们的行为不同

2、一个系统需要动态的在几种算法中选择一种

3、需要屏蔽算法规则



> 策略模式只能选择一种；如果需要选择多种需要使用装饰着模式



![image-20211208223527724](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211208223527.png)

上下文角色（Context）：用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略，算法直接访问，封装可能存在的变化

抽象策略角色（Strategy）：规定策略或算法的行为

具体策略角色（ConcreteStrategy）：具体的策略或算法实现





**多种支付方式**

![image-20211208225358618](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211208225358.png)

在Payment中定义了具体的支付消息返回。在AliPay。。。中定义了具体的扣款支付情况。在Order中得到用户实际选择的支付方式。





## 在Spring中的应用

```java
package org.springframework.core.io;


public interface Resource extends InputStreamSource {}
```

虽然没有直接使用Resource类，但是我们经常使用它的子类，例如

![image-20211208230902931](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211208230903.png)



## 优缺点

![image-20211208230942526](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211208230942.png)





# 责任链模式

责任链模式（Chain of Responsibility Pattern）是将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一个节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。

属于行为型模式。





## 适用场景

责任链模式类似生活中的审批流程、过五关斩六将

1、多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定

2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；

3、可动态指定一组对象处理请求。



![image-20211209094716449](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211209094716.png)

抽象处理者（Handler）：定义一个请求处理的方法，并维护一个下一个处理节点Handler对象的引用；

具体处理者（ConcreteHandler）：对请求进行处理，如果不敢兴趣，则进行转发。

> 责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；==节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。==



责任链一般和建造者模式一起使用

![image-20211209103336444](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211209112957.png))

![image-20211209103356032](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211209113043.png)



## 优缺点



**优点**

1、将请求与处理解耦

2、请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象；

3、具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果

4、链路结构灵活，可以通过改变链路结构动态地新增或删减责任

5、易于扩展新的请求处理类（节点），符合开闭原则



**缺点**

1、责任链太长或者处理时间过长，会影响整体性能

2、如果节点对象存在循环引用时，会造成死循环，导致系统崩溃



# 门面模式（Facade Pattern）

门面模式（Facade Pattern）又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口

特征：门面模式定义了一个高层接口，让子系统更容易使用

属于结构形模式



## 使用场景

子系统越来越复杂，增加门面模式提供简单的接口

构建多层系统结构，利用门面对象作为每层的入口，简化层间调用。



## 生活中的门面模式

![image-20211209162616234](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112091626667.png)



> 就像在Controller中集成各种service



![image-20211209163643672](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112091636159.png)

外观角色（Facade）：也称 门面角色，系统对外的统一接口；

子系统角色（SubSystem）：可以同时有一个或多个SubSystem。

facade持有对SubSystems的引用，子系统实现的方法通过facade来 让系统外的访问。



## 源码体现

Tomcat中的RequestFacade类,里面封装了非常多的request操作，也整合了其他servlet-api以外的内容分



## 门面模式与代理模式

门面模式就是静态代理模式

门面模式的重点在于封装

代理模式的重点在于增强

不做增强的静态代理就是门面模式



## 门面模式和单例模式

门面模式做成单例，工具包



## 门面模式优缺点

**优点**

1、简化了调用过程，无需深入了解子系统，以防给子系统带来风险

2、减少系统依赖，松散耦合

3、更好的划分访问层次，提高了安全性

4、遵循迪米特法则，即最少知道原则



**缺点**

1、当增加子系统和扩展子系统行为时，可能容易带来未知风险

2、不符合开闭原则

3、某些情况下可能违背单一职责原则



# 装饰者模式

装饰者模式（Decorator pattern）也叫包装模式（Wrapper Pattern），是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能）。

属于结构形模式



## **实现原理**

让装饰器实现被包装类（Concrete Component）相同的接口（Component）（使得装饰器与被扩展类类型一致），并在构造函数中传入该接口（Component）对象，然后就可以在接口需要实现的方法中在被包装类对于下部分的现有功能上添加新功能。而且由于装饰器与被包装类属于同一类型（均为Compant）且构造函数的参数为其实现接口类

![image-20211209173003460](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112091730795.png)

抽象组件（Component）：可以是一个接口或者抽象类，其充当被装饰类的原始对象，规定了被装饰对象的行为；

具体组件（ConcreteComponent）：实现/继承Component的一个具体对象，即被装饰的对象

抽象装饰器（Decorate）：通用的装饰ConcreteComponent的装饰器，其内部必然有一个属性指向Component抽象组件，其实现一般是一个抽象类，主要是为了让其子类按照其构造形式传入一个Component抽象组件，这是强制的通用行为（如果装饰逻辑单一，并不需要实现许多装饰器，那么我们可以直接省略该类，而直接实现一个具体装饰器（ConcreteDecorator）即可）

具体装饰器（ConcreteDector）：Dectorator的具体实现类，理论上，每个ConcreteDector都扩展Component对象的一种功能。



## **煎饼列子**

因为是做一个煎饼，相当于是给一个煎饼做装饰，往上面加鸡蛋、香肠什么的。先声明一个抽象组件

```java
public abstract class Battercake {

    protected abstract String getMsg();

    protected abstract int getPrice();

}
```

有了抽象组件就可以去声明一个具体的组件，这个组件才是要被修饰的组件。

```java
public class BaseBattercake extends Battercake{

    protected String getMsg(){ return "煎饼";}

    public int getPrice(){ return 5;}

}
```

准备好要修饰的组件，去准备装饰器。

因为煎饼可能会有不同的需求，需要加鸡蛋、加香肠；存在多种修饰逻辑的情况，因此需要先声明一个抽象的装饰器（如果没有的话在具体的装饰器中只能继承BaseBattercake或者Battercake，会不满足前一个就只会返回煎饼没有配料，后者是抽象的没有实现方法）。

```java
public class BattercakeDecorator extends Battercake{


    private Battercake battercake;

    public BattercakeDecorator(Battercake battercake) {
        this.battercake = battercake;
    }

    protected String getMsg(){ return this.battercake.getMsg();}

    public int getPrice(){ return this.battercake.getPrice();}

}
```

完成不同装饰器，实现抽象装饰器

```java
public class EggDecorator extends BattercakeDecorator{

    public EggDecorator(Battercake battercake) {
        super(battercake);
    }

    protected String getMsg(){ return super.getMsg() + "1个鸡蛋";}

    public int getPrice(){ return super.getPrice() + 1;}

}
```

```java
public class SauageDecorator extends BattercakeDecorator{

    public SauageDecorator(Battercake battercake) {
        super(battercake);
    }

    protected String getMsg(){ return super.getMsg() + "1根香肠";}

    public int getPrice(){ return super.getPrice() + 2;}

}
```

最后的测试

```java
public class Test {
    public static void main(String[] args) {


        Battercake battercake;

        battercake = new BaseBattercake();

        battercake = new EggDecorator(battercake);

        battercake = new EggDecorator(battercake);

        battercake = new SauageDecorator(battercake);

        System.out.println(battercake.getMsg() + ",总价" + battercake.getPrice());

    }
}
```



## logger

已经有了抽象组件Logger

```java
public interface Logger {
  .....
}
```



声明抽象装饰类

```java
public class LoggerDecorator implements Logger {
  。。。。
}
```

具体装饰

```java
public class JsonLogger extends LoggerDecorator {}
```





## 源码中的体现

spring中的TransactionAwareCacheDecorator

![image-20211209223603806](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211209223603.png)

就是对cache的包装



MVC中的HttpHeadResponseDecorator

![image-20211209223812626](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211209223812.png)



## 装饰器模式和代理模式对比

1、装饰器模式就是一种特殊的代理模式

2、装饰器模式强调的是自身功能的扩展，可动态的扩展

3、代理模式强调代理过程的控制

![image-20211209224040578](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211209224040.png)



## 优缺点

**优点**

1、装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态的扩展。

2、通过使用不同装饰以及这些装饰类的集合，可以实现不同效果

3、遵守开闭

**缺点**

1、会出现更多代码





# 迭代器模式

迭代器模式（Iterator Pattern）又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露集合内部表示

本质：抽离集合对象迭代行为到迭代器中，提供一致访问接口。

属于行为型模式。



## 现实例子

物流系统中的传送带，不管传送的是什么物品，都被打包成一个一个的箱子并且有一个统一的二维码。



## 适用场景

1、访问一个集合对象的内容而无需暴露它的内部表示

2、为便利不同的集合结构提供一个统一的访问接口





![image-20211210141218157](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101412941.png)

抽象迭代器（Iterator）：抽象迭代器负责定义访问和遍历元素的接口

具体迭代器（ConcreteIterator）：提供具体的元素遍历行为

抽象容器（Aggregate）：负责定义提供具体迭代器的接口

具体同期（Concrete Aggregate）：创建具体迭代器。



## 手写自定义迭代器

首先创建集合元素课程

![image-20211210142341365](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101423293.png)

然后自定义迭代器Iterator接口

![image-20211210142418554](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101424994.png)

创建自定义的课程的集合接口

![image-20211210142509315](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101425098.png)



分别实现迭代器接口和集合接口

![image-20211210143710762](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101437528.png)

![image-20211210143721829](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101437730.png)

test

![image-20211210143748328](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101437273.png)



## 迭代器模式在源码中的体现

JDK中的Iterator

```JAVA
public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

同样定义了两个方法 hasNext(); next();



ArrayList中的，内部类Itr重新去实现Iterator接口

```java
private class Itr implements Iterator<E> {
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;
    
    public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }
    
    .....
        ....
    
}
```



其他还有一些内部类对Itr进行扩展

```java
private class ListItr extends Itr implements ListIterator<E> {
    ListItr(int index) {
        super();
        cursor = index;
    }

    public boolean hasPrevious() {
        return cursor != 0;
    }
    .....
    .....
    .....
}
```

主要是扩展了一个hasPrevious方法，用来判断是否有上一个



## 迭代器模式的优缺点

**优点**

1、多态迭代：为不同的聚合结构提供一致的遍历接口，即一个迭代接口可以访问不同的集合对象；

2、简化集合对象接口：迭代器模式将集合对象本身应该提供的元素迭代接口抽取到了迭代器中，使集合对象无需关心具体迭代行为；

3、元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使的同种元素聚合结构可以有不同的迭代行为；

4、解耦迭代与集合：迭代器模式 封装了具体的迭代算法，迭代算法的变化，不会影响到集合对象的架构



**缺点**

1、对于比较简单的遍历（像数组或者有序列表），使用迭代器方式较为繁琐

在日常开发中，几乎不会用到自己写迭代器。除非定制一个自己实现的数据结构。





# 命令模式（Command Pattern）

是对命令的封装，每一个命令都是一个操作：请求的以防发出请求要求执行一个操作；接受的一方收到请求，并执行操作。命令模式解耦了请求方和接受方，请求方只需请求执行命令，不用关心命令是怎样被接收，怎样被操作以及是否被执行......等。

本质：解耦命令请求与处理

属于行为形 模式



## 生活场景的应用

遥控器、餐厅点菜单



![image-20211210160724762](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112101607430.png)

接收者（Receiver）：该类负责具体实施或执行一个请求

命令角色（Command）：定义需要执行的所有命令行为，直接在内部创建接受者，不暴露给客户端

具体命令角色（ConcreteCommand）：该类内部维护一个接收者（Receiver），在其execute()方法中调用Receiver的相关方法

请求者角色（invoker）：接收客户端命令，并执行命令



Command就是作为Receiver和Invoker的中间件;

> 解耦请求与实现：即解耦了Invoker和Receiver，因为在UML类图中，Invoker是一个具体的实现，等待接收客户端传入命令（即Invoker与客户端耦合），Invoker处于业务逻辑区域，应当是一个稳定的结构。Receiver是属于业务功能模块，是经常变动的，如果没有Command，则Invoker紧耦合Receiver，一个稳定的结构依赖了一个不稳定的结构，就会导致整个结构偶读不稳定



## 业务场景的使用

开发一个播放器，播放器有播放功能、拖动进度条功能、停止播放功能、暂停功能。

将这些封装成指令发送给内核Gplay类；

首先拥有GPlayer类(作为receiver)

```java
public class GPlayer {
    public void play(){
        System.out.println("正常播放");
    }

    public void speed(){
        System.out.println("拖动进度条");
    }

    public void stop(){
        System.out.println("停止播放");
    }

    public void pause(){
        System.out.println("暂停播放");
    }
}
```



对于命令需要有一个命令接口

```JAVA
public interface IAction {
    void execute();
}
```



然后对于不同类型的指令，进行包装，完成时限类

 

```java
public class PauseAction implements IAction {
    private GPlayer gplayer;

    public PauseAction(GPlayer gplayer) {
        this.gplayer = gplayer;
    }

    public void execute() {
        gplayer.pause();
    }
}
```



最后创建控制条

```JAVA
public class Controller {
    private List<IAction> actions = new ArrayList<IAction>();

    public void addAction(IAction action){
        actions.add(action);
    }

    public void execute(IAction action){
        action.execute();
    }

    public void executes(){
        for (IAction action:actions) {
            action.execute();
        }
        actions.clear();
    }



}
```



## 源码中的体现

JDK中的Runable接口，实际上Runnable就相当于是命令的抽象，只要是实现了Runnable接口的类都被认为是一个线程

start()就是个命令



## 优缺点

**优点**

1、通过引入中间件（抽象接口），解耦了命令请求与实现

2、扩展性良好，可以很容易的增加命令

3、支持组合命令，支持命令队列

4、可以在现有命令的基础上，增加额外功能（比如日志记录，结合装饰者模式）



**缺点**

1、具体命令类可能过多

2、命令模式的结果其实就是接收方的执行结果，但是为了解耦，引入过多的类





# 状态模式（State Pattern）

状态模式（State Pattern）也称为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类

属于行为模式

状态模式中类的行为是由状态决定的，不同的状态下有不同的行为。其意图是让一个对象在其内部改变的时候，其行为也随之改变。状态模式核心是状态与行为绑定



## 适用场景

存在多种情况最直接的方法就是使用if...else或 switch...case。

状态模式主要解决的就是当控制一个对象状态的条件表达式过于复杂的时候。通过把状态的判断逻辑转移到不同状态的一系列类中。

1、行为随着状态改变而改变的场景

2、一个操作中含有庞大的多分支结构，并且这些分支取决于对象的状态



![image-20211211170125518](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211211170125.png)

1、环境类角色（Context）：定义客户端需要的借口，内部维护一个当前状态实例，并负责具体状态的切换

2、抽象状态角色（IState）：定义该状态下的行为，可以有一个或多个行为，不做具体实现

3、具体状态角色（ConcreState）：具体实现该状态对应对行为，并且在需要的情况下进行状态切换（setState方法）。



## 业务场景

对于社区中的文章写的好，我们一般都会评论、收藏。但是如果不是登陆的情况下需要先登陆然后执行其他操作。现在这里设计的状态有两种：登陆与未登录，行为有两种：评论，收藏。

首先创建抽象角色UserState类（不一定要是接口）,与基础的相比多了一个上下文context，用来存放当前状态

```java
public abstract class UserState {
    protected AppContext context;

    public void setContext(AppContext context) {
        this.context = context;
    }

    public abstract void favorite();

    public abstract void comment(String comment);
}
```

创建登陆状态

```java
public class LoginState extends UserState {
    @Override
    public void favorite() {
        System.out.println("收藏成功！");
    }

    @Override
    public void comment(String comment) {
        System.out.println(comment);
    }
}
```

创建未登录状态

```java
public class UnLoginState extends UserState {

    @Override
    public void favorite() {
        this.switch2login();
        this.context.getState().favorite();
    }

    @Override
    public void comment(String comment) {
        this.switch2login();
        this.context.getState().comment(comment);
    }

    private void switch2login(){
        System.out.println("跳转到登录页！");
        this.context.setState(this.context.STATE_LOGIN);
    }
}
```

创建上下文角色

```java
public class AppContext {

    public static final UserState STATE_LOGIN = new LoginState();
    public static final UserState STATE_UNLOGIN = new UnLoginState();

    private UserState currentState = STATE_UNLOGIN;

    {
        STATE_LOGIN.setContext(this);
        STATE_UNLOGIN.setContext(this);
    }

    public void setState(UserState state){
        this.currentState = state;
    }

    public UserState getState(){
        return this.currentState;
    }

    public void favorite(){
        this.currentState.favorite();
    }

    public void comment(String comment){
        this.currentState.comment(comment);
    }
}
```





## 利用状态机实现订单状态流转控制

状态机是状态模式的一种应用，相当于上下文角色的一个升级版。在工作流或游戏等各种系统中有大量食用，如各种工作引擎，它几乎是状态机等子集和实现。

Spring也提供流一个API。组件StateMachine。

用状态机模拟一个订单状态流转

1、添加依赖

```xml
<dependency>
    <groupId>org.springframework.statemachine</groupId>
    <artifactId>spring-statemachine-core</artifactId>
    <version>2.0.1.RELEASE</version>
</dependency>
```



2、创建订单状态枚举类和状态转换枚举类

```java
/**
 * 订单状态
 */
public enum OrderStatus {
    // 待支付，待发货，待收货，订单结束
    WAIT_PAYMENT, WAIT_DELIVER, WAIT_RECEIVE, FINISH;
}
```

```java
/**
 * 订单状态改变事件
 */
public enum OrderStatusChangeEvent {
    // 支付，发货，确认收货
    PAYED, DELIVERY, RECEIVED;
}
```



3、添加状态流转配置

```java
@Configuration
@EnableStateMachine(name = "orderStateMachine")
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderStatus, OrderStatusChangeEvent> {
 
    /**
     * 配置状态
     * @param states
     * @throws Exception
     */
    public void configure(StateMachineStateConfigurer<OrderStatus, OrderStatusChangeEvent> states) throws Exception {
        states
                .withStates()
                .initial(OrderStatus.WAIT_PAYMENT)
                .states(EnumSet.allOf(OrderStatus.class));
    }
 
    /**
     * 配置状态转换事件关系
     * @param transitions
     * @throws Exception
     */
    public void configure(StateMachineTransitionConfigurer<OrderStatus, OrderStatusChangeEvent> transitions) throws Exception {
        transitions
                //待支付的下一个状态是待发货，中间要经过支付阶段
                .withExternal().source(OrderStatus.WAIT_PAYMENT).target(OrderStatus.WAIT_DELIVER).event(OrderStatusChangeEvent.PAYED)
                .and()
                //待发货下一阶段是待收获，要经过发货
                .withExternal().source(OrderStatus.WAIT_DELIVER).target(OrderStatus.WAIT_RECEIVE).event(OrderStatusChangeEvent.DELIVERY)
                .and()
                .withExternal().source(OrderStatus.WAIT_RECEIVE).target(OrderStatus.FINISH).event(OrderStatusChangeEvent.RECEIVED);
    }
 
    /**
     * 持久化配置
     * 实际使用中，可以配合redis等，进行持久化操作
     * @return
     */
    @Bean
    public DefaultStateMachinePersister persister(){
        return new DefaultStateMachinePersister<>(new StateMachinePersist<Object, Object, Order>() {
            @Override
            public void write(StateMachineContext<Object, Object> context, Order order) throws Exception {
                //此处并没有进行持久化操作
            }
 
            @Override
            public StateMachineContext<Object, Object> read(Order order) throws Exception {
                //此处直接获取order中的状态，其实并没有进行持久化读取操作
                return new DefaultStateMachineContext(order.getStatus(), null, null, null);
            }
        });
    }
}
```

4、添加订单状态监听器

```java
@Component("orderStateListener")
@WithStateMachine(name = "orderStateMachine")
public class OrderStateListenerImpl{
 
    @OnTransition(source = "WAIT_PAYMENT", target = "WAIT_DELIVER")
    public boolean payTransition(Message<OrderStatusChangeEvent> message) {
        Order order = (Order) message.getHeaders().get("order");
        order.setStatus(OrderStatus.WAIT_DELIVER);
        System.out.println("支付，状态机反馈信息：" + message.getHeaders().toString());
        return true;
    }
 
    @OnTransition(source = "WAIT_DELIVER", target = "WAIT_RECEIVE")
    public boolean deliverTransition(Message<OrderStatusChangeEvent> message) {
        Order order = (Order) message.getHeaders().get("order");
        order.setStatus(OrderStatus.WAIT_RECEIVE);
        System.out.println("发货，状态机反馈信息：" + message.getHeaders().toString());
        return true;
    }
 
    @OnTransition(source = "WAIT_RECEIVE", target = "FINISH")
    public boolean receiveTransition(Message<OrderStatusChangeEvent> message){
        Order order = (Order) message.getHeaders().get("order");
        order.setStatus(OrderStatus.FINISH);
        System.out.println("收货，状态机反馈信息：" + message.getHeaders().toString());
        return true;
    }
}
```



5、创建IorderService接口

```java
public interface IOrderService {
    //创建新订单
    Order create();
    //发起支付
    Order pay(int id);
    //订单发货
    Order deliver(int id);
    //订单收货
    Order receive(int id);
    //获取所有订单信息
    Map<Integer, Order> getOrders();
}
```



6、在Service业务逻辑中的应用

```java
@Service("orderService")
public class OrderServiceImpl implements IOrderService {

    @Autowired
    private StateMachine<OrderStatus, OrderStatusChangeEvent> orderStateMachine;
 
    @Autowired
    private StateMachinePersister<OrderStatus, OrderStatusChangeEvent, Order> persister;
 
    private int id = 1;
    private Map<Integer, Order> orders = new HashMap<>();

    public Order create() {
        Order order = new Order();
        order.setStatus(OrderStatus.WAIT_PAYMENT);
        order.setId(id++);
        orders.put(order.getId(), order);
        return order;
    }

    public Order pay(int id) {
        Order order = orders.get(id);
        System.out.println("线程名称：" + Thread.currentThread().getName() + " 尝试支付，订单号：" + id);
        Message message = MessageBuilder.withPayload(OrderStatusChangeEvent.PAYED).setHeader("order", order).build();
        if (!sendEvent(message, order)) {
            System.out.println("线程名称：" + Thread.currentThread().getName() + " 支付失败, 状态异常，订单号：" + id);
        }
        return orders.get(id);
    }

    public Order deliver(int id) {
        Order order = orders.get(id);
        System.out.println("线程名称：" + Thread.currentThread().getName() + " 尝试发货，订单号：" + id);
        if (!sendEvent(MessageBuilder.withPayload(OrderStatusChangeEvent.DELIVERY).setHeader("order", order).build(), orders.get(id))) {
            System.out.println("线程名称：" + Thread.currentThread().getName() + " 发货失败，状态异常，订单号：" + id);
        }
        return orders.get(id);
    }

    public Order receive(int id) {
        Order order = orders.get(id);
        System.out.println("线程名称：" + Thread.currentThread().getName() + " 尝试收货，订单号：" + id);
        if (!sendEvent(MessageBuilder.withPayload(OrderStatusChangeEvent.RECEIVED).setHeader("order", order).build(), orders.get(id))) {
            System.out.println("线程名称：" + Thread.currentThread().getName() + " 收货失败，状态异常，订单号：" + id);
        }
        return orders.get(id);
    }
 

    public Map<Integer, Order> getOrders() {
        return orders;
    }
 
 
    /**
     * 发送订单状态转换事件
     *
     * @param message
     * @param order
     * @return
     */
    private synchronized boolean sendEvent(Message<OrderStatusChangeEvent> message, Order order) {
        boolean result = false;
        try {
            orderStateMachine.start();
            //尝试恢复状态机状态
            persister.restore(orderStateMachine, order);
            //添加延迟用于线程安全测试
            Thread.sleep(1000);
            result = orderStateMachine.sendEvent(message);
            //持久化状态机状态
            persister.persist(orderStateMachine, order);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            orderStateMachine.stop();
        }
        return result;
    }
}
```

```java
public class Order {
    private int id;
    private OrderStatus status;
    public void setStatus(OrderStatus status) {
        this.status = status;
    }

    public OrderStatus getStatus() {
        return status;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "订单号：" + id + ", 订单状态：" + status;
    }
}
```



7、测试案例

```java
@SpringBootApplication
public class Test {
    public static void main(String[] args) {

        Thread.currentThread().setName("主线程");

        ConfigurableApplicationContext context = SpringApplication.run(Test.class,args);

        IOrderService orderService = (IOrderService)context.getBean("orderService");

        orderService.create();
        orderService.create();

        orderService.pay(1);

        new Thread("客户线程"){
            @Override
            public void run() {
                orderService.deliver(1);
                orderService.receive(1);
            }
        }.start();

        orderService.pay(2);
        orderService.deliver(2);
        orderService.receive(2);

        System.out.println("全部订单状态：" + orderService.getOrders());

    }
}
```



## 源码中的体现

JSF比较经典的前段框架



## 状态模式与责任链模式

两个模式都能消除if分支过多的问题，某种情况下状态模式中的装爱可以理解为责任。装套模式强调的是一个对象内部的改变，责任链模式是对外部及诶单对象间的改变

从代码上看，他们最大的区别是状态模式各个状态对象自己下一个要进入的装套对象；而责任链并不清楚下一个节点的对象，因为链式组装由客户端负责。



## 状态模式与策略模式

策略模式多种算法行为选择其一，彼此是独立的。

状态模式各个状态间存在相互关系



## 优缺点

![image-20211211233532042](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212115908.png)

![image-20211211233547474](/Users/zhuyihui/Library/Application%20Support/typora-user-images/image-20211211233547474.png)





# 备忘录模式（Memento Pattern）

又称为快照模式（Snapshot Pattern）或令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个对象内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复发哦原先保存的状态。

特征：“后悔药”

属于行为型模式



## 适用场景

1、需要保存历史快照的场景

2、希望在对象之外保存状态，且除了自己其他类对象无法访问状态保存具体内容。



![image-20211212121436794](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212121436.png)

发起人角色（Originator）：负责创建一个备忘录，记录自身需要保存的状态；具备状态回滚功能

备忘录角色（Memento）：用于存储Originator的内部状态，且可以防止Originator以外的对象进行访问。

备忘里管理元角色（Caretaker）：负责存储，提供管理备忘录（Memento），无法对备忘录内容进行操作和访问。



## 利用压栈管理落地备忘录模式

一些网页中的文本编辑器都是会附带草稿箱、撤销等这样的操作

首先创建发起人角色编辑器Editor类

```java
public class Editor {

    private String title;
    private String content;
    private String imgs;

    public Editor(String title, String content, String imgs) {
        this.title = title;
        this.content = content;
        this.imgs = imgs;
    }

    public String getTitle() {
        return title;
    }

    public String getContent() {
        return content;
    }

    public String getImgs() {
        return imgs;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public void setImgs(String imgs) {
        this.imgs = imgs;
    }

    public ArticleMemento saveToMemento(){
        ArticleMemento articleMemento = new ArticleMemento(this.title,this.content,this.imgs);
        return articleMemento;
    }

    public void undoFromMemento(ArticleMemento articleMemento){
        this.title = articleMemento.getTitle();
        this.content = articleMemento.getContent();
        this.imgs = articleMemento.getImgs();
    }

    @Override
    public String toString() {
        return "Editor{" +
                "title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", imgs='" + imgs + '\'' +
                '}';
    }
}
```



创建备忘录角色ArticleMemento

```java
public class ArticleMemento {
    private String title;
    private String content;
    private String imgs;

    public ArticleMemento(String title, String content, String imgs) {
        this.title = title;
        this.content = content;
        this.imgs = imgs;
    }

    public String getTitle() {
        return title;
    }

    public String getContent() {
        return content;
    }

    public String getImgs() {
        return imgs;
    }

    @Override
    public String toString() {
        return "ArticleMemento{" +
                "title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", imgs='" + imgs + '\'' +
                '}';
    }
}
```



然后创建备忘录管理角色草稿箱DraftsBox类

```java
public class DraftsBox {
    private final Stack<ArticleMemento> STACK = new Stack<ArticleMemento>();

    public ArticleMemento getMemento(){
        ArticleMemento articleMemento = STACK.pop();
        return articleMemento;
    }

    public void addMemento(ArticleMemento articleMemento){
        STACK.push(articleMemento);
    }

}
```



## 源码中的体现

Spring 中的 webflow源码中StateManageableMessageContext接口。



## 备忘录模式的优缺点

**优点**

1、简化发起人实体类（Originator）职责，隔离状态存储与获取，实现了信息的封装，客户端无需关心状态的保存细节

2、提供状态回滚功能

**缺点**

1、消耗资源：如果需要保存的状态过多时，每一次保存都会消耗很多内存。





# 中介者模式（Mediator Pattern）

又称为调解者模式或调停者模式。用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互。

核心：通过中介者结偶系统各层次对象的直接耦合，层次对象的对外依赖通信交由中介者转发

行为型模式





## 现实中的场景

多个对象都与多个对象进行交互时，将会形成如下图所示的网状结构

![image-20211212211503067](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212211503.png)

网状结构每个对象之间过度耦合，这样不利于信息的复用也不利于扩展。

引入中介者模式就会转变为星型结构

![image-20211212211637512](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212211637.png)

转换成星形之后，任何一个类的变化就只会影响中介者和类本身，大大减少系统的耦合程度



日常生活中的朋友圈就是一个中介者。信息交易平台也是



## 使用场景

1、系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解

2、交互的公共行为，如果需要改变行为则可以增加新的中介者类。

![image-20211212212328722](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212212328.png)

抽象中介者（Mediator）：定义同一的接口，用于各同时角色之间的通信transferA、transferB；

具体中介者（ConcreteMediator）：从具体的同时对象接收消息，向具体同时对象发出命令，协调各同事间的协作；

抽象同事类（Colleague）：每一个同事对象均需要依赖中介者角色，与其他同事间通信时，交由中介者进行转发协作；

具体同事类（ConcreteColleague）：负责实现自发行为（self-Method），转发依赖方法（Dep-Method）交由中介者进行协调。

> 中介者持有同事类，在调用的同事类的方法中调用中介者的方法进行处理。



## 中介者模式群聊场景

构建一个聊天室系统，用户可以向聊天室发送消息，聊天室会向所有的用户显示消息。实际上就是用户发送信息到服务器上，然后服务器在将消息发送给聊天室进行显示。

创建User

```java
public class User {
    private String name;
    private ChatRoom chatRoom;

    public User(String name, ChatRoom chatRoom) {
        this.name = name;
        this.chatRoom = chatRoom;
    }

    public String getName() {
        return name;
    }

    public void sendMessage(String msg){
        this.chatRoom.showMsg(this,msg);
    }
}
```



创建ChatRoom类

```java
public class ChatRoom {

    public void showMsg(User user,String msg){
        System.out.println("[" + user.getName() + "] : " + msg);
    }
}
```





## 中介者模式和代理模式的区别

1、中间角色：前线搭桥

2、为什么要代理？因为你做不到，又必须做

3、中介者，只要联系，就不管了，后面的事情全权自己完成





## 在源码中的体现

JDK中的Timer类，Time类中有许多schedule()重载

![截屏2021-12-12 下午10.01.19](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212220157.png)



每一个都是调用了sched()方法

![image-20211212220300706](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212220300.png)



![image-20211212220534927](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212220559.png)我们发现这个方法里面对task不做任何处理，只是将任务放到queue中。这些传入的任务就像是同事，同事之间通过Timer来协调完成（按照顺序执行)。



> ==开发中如果遇到网状的结构可以用中介者模式==



## 中介者模式的优缺点

**优点**

1、减少类见依赖，将多对多依赖转换为一对多

2、类见各司其职

**缺点**

中介者模式中将原本多个对象直接多相互依赖变成来中介者和多个同事类的依赖关系。当同事类越多就越会臃肿。





# 解释器模式（Interpreter Pattern）

给定一个语言，定义它的文法的一种表示，并定义一个解释器使用该表示来解释语言中的句子

特征：为了解释一种语言，而为语言创建的解释器

属于行为型模式





## 应用场景

摩斯密码：一种特殊的解释器



1、一些重复出现的问题可以用一种简单的语言来进行表达

2、一个简单语法需要解释的场景



![image-20211212221926815](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211212221926.png)

抽象表达式（Expression）：负责定义一个解释方法interpret，交由具体子类进行具体解释

终结符表达式（TerminalExpression）：实现文法中与终极符有关的解释操作。文法中的每一个终结符都有一个具体终结表达式与之相对应，比如共识 R = R1+R2，R1、R2就是终结符

非终结表达式（NonterminalExpression）：实现文法中与非终结符有关的解释操作。文法中每条规则都对应一个非终结符表达式；

上下文环境（Context）；包含解释器之外的全局信息。他的任务一般是用来存放各个终结符所对应的具体值，比如R = R1 + R2，给R1赋100，给R2赋200这些细腻下需要存放到环境中。





## 使用解释器模式解析数学表达式

首先定义抽象表达式角色IArithmeticInterpreter接口：

```java
public interface IArithmeticInterpreter {
    int interpret();
}
```



创建终结表达式角色Interpreter抽象类：

```java
public abstract class Interpreter implements IArithmeticInterpreter {

    protected IArithmeticInterpreter left;
    protected IArithmeticInterpreter right;

    public Interpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) {
        this.left = left;
        this.right = right;
    }
}
```





# 各设计模式总结与对比

![image-20211213160633085](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112131606088.png)



![image-20211213161204456](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112131612024.png)



| 分类   | 设计模式                                                     |
| ------ | ------------------------------------------------------------ |
| 创建型 | 工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、单例模式（Singleton）、原型模式（Prototype）、建造者模式（Builder） |
| 结构形 | 代理模式（Proxy）、门面模式（Facade）、装饰器模式（decorator）、享元模式（Flyweight）、组合模式（Composite）、适配器模式（Adapter）、桥接模式（Bridge） |
| 行为型 | 模板方法模式（Template Method）、策略模式（Strategy）、责任链模式（Chain of Responsibility）、迭代器模式（Iterator）、命令模式（Command）、状态模式（State）、备忘录模式（Memento）、中介者模式（Mediator）、解释器模式（interpreter）、观察者模式（Observer）、访问者模式（Visitor） |



创建者模式中的原型模式不需要自己造轮子（实现Cloneable接口）

![image-20211213223228419](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211213223228.png)

![image-20211213223242222](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211213223503.png)

![image-20211213223253758](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/20211213223426.png)



## 一句话概括

| 设计模式                              | 一句话归纳                                               | 目的                 | 生活案例             | 框架源码举例                                        |
| ------------------------------------- | -------------------------------------------------------- | -------------------- | -------------------- | --------------------------------------------------- |
| 工厂模式（Factory）                   | 产品标准化                                               | 封装创建细节         | 实体工厂             | Loggerfactory、Calender                             |
| 单例模式（Singleton）                 | 独一无二                                                 | 保证独一无二         | CEO                  | BeanFactory、Runntime                               |
| 原型模式（Prototype）                 | 拔一根猴毛，吹出千万个                                   | 高效创建对象         | 克隆                 | ArrayList、PropertypeBean                           |
| 建造者模式（Builder）                 | 自由选择配置                                             | 开放个性配置步骤     | 选配                 | StringBuilder、BeanDefinitionBuilder                |
| 代理模式（Proxy）                     | 做不到的事让别人做                                       | 增强只能             | 媒婆                 | ProxyFactoryBean、JdkDynamicAopProxy、CgLibAopProxy |
| 门面模式（Facade）                    | 打开一扇门，走向全世界                                   | 同一访问入口         | 前台                 | JDbcUtils、RequestFacade                            |
| 装饰器模式（Decorator）               | 同宗同源、统一个继承体系                                 | 灵活扩展、同宗同源   | 煎饼                 | Buffered Reader、InputStream                        |
| 享元模式（Flyweight）                 | 优化资源配置、减少重复浪费                               | 共享资源池           | 全国社保网络         | String、Integer、ObjectPool                         |
| 组合模式（Composite）                 | 人在一起叫团队                                           | 同一整体和个体       | 组织架构书、文件目录 | HashMap、SqlNode                                    |
| 适配器模式（Adapter）                 | 适合自己的，才是最好的                                   | 兼容转换（求同存异） | 电源适配             | AdvisorAdapter、handlerAdapter                      |
| 桥接模式（Bridge）                    | 约定由于配置                                             | 不允许用继承         | 桥                   | Drivermanager                                       |
| 委派模式（Delegate）                  | 这个需求很简单，怎么实现我不管                           | 支队结果负责         | 授权委托书           | ClassLoader、BeandefinitionParserdelegate           |
| 模板模式（Template）                  | 流程（步骤）全部标准化，需要微调请覆盖                   | 逻辑复用             | 把大象放进冰箱的步骤 | JdbcTemplate、HttpServlet                           |
| 策略模式（Strategy）                  | 条条大路通罗马，具体的道路自己选择                       | 把选择权交给用户     | 选择支付方式         | Comarator                                           |
| 责任链模式（Chain of responsibility） | 维护好自己的处理，和下一个处理的节点（链表）             | 接耦处理请求         | 踢皮球               | FilterChain、Pipeline                               |
| 迭代器模式（Iterator）                | 流水线上坐一天，每个包裹扫一遍（不知道包裹里面的是什么） | 统一对集合的访问方式 | 统一刷脸新站         | Iterator                                            |
| 命令模式（Command）                   | 运筹帷幄之中，决胜千里之外                               | 解耦请求和处理       | 遥控器               | Runnable、TestCase                                  |
| 状态模式（State）                     | 状态驱动行为，行为决定状态                               | 绑定状态和行为       | 订单状态跟踪         | Lifecycle                                           |
| 备忘录（Memento）                     | 后悔药                                                   | 备份                 | 草稿箱               | StatemanageableMessagecontenxt                      |
| 中介者（Mediator）                    | 联系方式给你，怎么搞定不管                               | 统一管理网状资源     | 朋友圈               | Timer                                               |
| 解释器模式（Interpreter）             | 一切解释权归我所有                                       | 实现特定语法的解析   | 摩斯密码             | pattern                                             |
| 观察者模式（Observe）                 |                                                          |                      |                      |                                                     |
| 访问者模式                            |                                                          |                      |                      |                                                     |



![image-20211214113450534](https://cdn.jsdelivr.net/gh/Mirror0oo0/Figurebed/202112141134969.png)



## 单例模式和工厂模式

实际业务代码中,通常会把工厂类设计为单例。

## 策略模式和工厂模式

1、工厂模式包含工厂方法模式和抽象工厂模式是创建型模式,策略模式属于行为型模式。
2、厂模式主要目的是封装好创建逻辑,策略模式接收工厂创建好的对象,从而实现不同的行为。

## 策略模式和委派模式

1、策略模式是委派模式内部的一-种实现形式,策略模式关注的结果是否能相互替代。
2、委派模式更关注分发和调度的过程。



## 策略VS委派

共同点:行为型模式
不同点:策略模式能否相互替换，委派模式分发和调度的过程.
关联:切换的上下文



## 工厂方法模式vs抽象工厂模式

共同点: 1、创建型模式; 2、职责相同
不同点:
创建出来的产品扩展程度不一样,
工厂 方法单维度扩展，抽象工厂可以实现多维度扩展
关联:工厂方法很多情况下会作为抽象工厂的子类!



## 中介模式vs桥接模式

共同点:具备两个对象建立联系
不同点:1、行为型vs结构型
			 2、中介者将多维度网状结构的对象建立联系;
			 桥接模式将两个维度(抽象和具象)
关联:
中介者是更复杂的桥



## 代理模式vs委派模式

共同点:都有保护目标对象的特性
不同点:1、结构型vs行为型
		     2、职责不同，委派模式不对目标的功能做增强
				代理是一定要干活的
关联:
委派就是全权静态代理，没有增强的代理就是委派



## 桥接模式vS适配器模式

共同点: 1、都是结构型
			  2、都存在对象的间接引用关系
不同点: 

1、使用场景不同，适配器希望已有代码稳定的，桥接希望已有代码是扩展的
2、原则不同:桥接不推荐使用继承的，适配器会采用继承



## 代理模式VS适配器模式

共同点: 1、结构型模式
2、包装器模式的实现
3、都起到了隐藏和保护目标对象的作用
不同点:目的不同，代理为了功能增强、适配器为了解决兼容问题
关联:对象适配器其实就是静态代理的一种实现



## 适配器vs装饰器

共同点:

1、都属于结构型模式
2、包装器模式的一-种

不同点:

1、装饰器同宗同源，适配器纯属伪装
2、目的不同:适配器是为兼容(转换)、装饰器是为增强(不改变原有功能)
关联:结构上有点类似
